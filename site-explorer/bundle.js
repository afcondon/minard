#!/usr/bin/env node
/* Generated by Spago v0.93.45 */import __module from 'module';import __path from 'path';import __url from 'url';const require = __module.createRequire(import.meta.url);const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url));const __filename=new URL(import.meta.url).pathname

// output/Control.Apply/foreign.js
var arrayApply = function(fs) {
  return function(xs) {
    var l = fs.length;
    var k = xs.length;
    var result = new Array(l * k);
    var n = 0;
    for (var i = 0; i < l; i++) {
      var f = fs[i];
      for (var j = 0; j < k; j++) {
        result[n++] = f(xs[j]);
      }
    }
    return result;
  };
};

// output/Control.Semigroupoid/index.js
var semigroupoidFn = {
  compose: function(f) {
    return function(g) {
      return function(x) {
        return f(g(x));
      };
    };
  }
};

// output/Control.Category/index.js
var identity = function(dict) {
  return dict.identity;
};
var categoryFn = {
  identity: function(x) {
    return x;
  },
  Semigroupoid0: function() {
    return semigroupoidFn;
  }
};

// output/Data.Boolean/index.js
var otherwise = true;

// output/Data.Function/index.js
var flip = function(f) {
  return function(b) {
    return function(a) {
      return f(a)(b);
    };
  };
};
var $$const = function(a) {
  return function(v) {
    return a;
  };
};

// output/Data.Functor/foreign.js
var arrayMap = function(f) {
  return function(arr) {
    var l = arr.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(arr[i]);
    }
    return result;
  };
};

// output/Data.Unit/foreign.js
var unit = void 0;

// output/Data.Functor/index.js
var map = function(dict) {
  return dict.map;
};
var $$void = function(dictFunctor) {
  return map(dictFunctor)($$const(unit));
};
var functorArray = {
  map: arrayMap
};

// output/Control.Apply/index.js
var applyArray = {
  apply: arrayApply,
  Functor0: function() {
    return functorArray;
  }
};
var apply = function(dict) {
  return dict.apply;
};

// output/Control.Applicative/index.js
var pure = function(dict) {
  return dict.pure;
};
var when = function(dictApplicative) {
  var pure1 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return pure1(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var liftA1 = function(dictApplicative) {
  var apply2 = apply(dictApplicative.Apply0());
  var pure1 = pure(dictApplicative);
  return function(f) {
    return function(a) {
      return apply2(pure1(f))(a);
    };
  };
};

// output/Control.Bind/foreign.js
var arrayBind = function(arr) {
  return function(f) {
    var result = [];
    for (var i = 0, l = arr.length; i < l; i++) {
      Array.prototype.push.apply(result, f(arr[i]));
    }
    return result;
  };
};

// output/Control.Bind/index.js
var discard = function(dict) {
  return dict.discard;
};
var bindArray = {
  bind: arrayBind,
  Apply0: function() {
    return applyArray;
  }
};
var bind = function(dict) {
  return dict.bind;
};
var discardUnit = {
  discard: function(dictBind) {
    return bind(dictBind);
  }
};

// output/Data.Array/foreign.js
var replicateFill = function(count, value) {
  if (count < 1) {
    return [];
  }
  var result = new Array(count);
  return result.fill(value);
};
var replicatePolyfill = function(count, value) {
  var result = [];
  var n = 0;
  for (var i = 0; i < count; i++) {
    result[n++] = value;
  }
  return result;
};
var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
var length = function(xs) {
  return xs.length;
};
var indexImpl = function(just, nothing, xs, i) {
  return i < 0 || i >= xs.length ? nothing : just(xs[i]);
};
var findIndexImpl = function(just, nothing, f, xs) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (f(xs[i])) return just(i);
  }
  return nothing;
};
var concat = function(xss) {
  if (xss.length <= 1e4) {
    return Array.prototype.concat.apply([], xss);
  }
  var result = [];
  for (var i = 0, l = xss.length; i < l; i++) {
    var xs = xss[i];
    for (var j = 0, m = xs.length; j < m; j++) {
      result.push(xs[j]);
    }
  }
  return result;
};
var filterImpl = function(f, xs) {
  return xs.filter(f);
};
var sliceImpl = function(s, e, l) {
  return l.slice(s, e);
};
var anyImpl = function(p, xs) {
  var len = xs.length;
  for (var i = 0; i < len; i++) {
    if (p(xs[i])) return true;
  }
  return false;
};
var unsafeIndexImpl = function(xs, n) {
  return xs[n];
};

// output/Data.Semigroup/foreign.js
var concatString = function(s1) {
  return function(s2) {
    return s1 + s2;
  };
};
var concatArray = function(xs) {
  return function(ys) {
    if (xs.length === 0) return ys;
    if (ys.length === 0) return xs;
    return xs.concat(ys);
  };
};

// output/Data.Semigroup/index.js
var semigroupString = {
  append: concatString
};
var semigroupArray = {
  append: concatArray
};
var append = function(dict) {
  return dict.append;
};

// output/Control.Monad/index.js
var ap = function(dictMonad) {
  var bind4 = bind(dictMonad.Bind1());
  var pure7 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind4(f)(function(f$prime) {
        return bind4(a)(function(a$prime) {
          return pure7(f$prime(a$prime));
        });
      });
    };
  };
};

// output/Data.Bounded/foreign.js
var topChar = String.fromCharCode(65535);
var bottomChar = String.fromCharCode(0);
var topNumber = Number.POSITIVE_INFINITY;
var bottomNumber = Number.NEGATIVE_INFINITY;

// output/Data.Ord/foreign.js
var unsafeCompareImpl = function(lt) {
  return function(eq3) {
    return function(gt) {
      return function(x) {
        return function(y) {
          return x < y ? lt : x === y ? eq3 : gt;
        };
      };
    };
  };
};
var ordStringImpl = unsafeCompareImpl;
var ordCharImpl = unsafeCompareImpl;

// output/Data.Eq/foreign.js
var refEq = function(r1) {
  return function(r2) {
    return r1 === r2;
  };
};
var eqCharImpl = refEq;
var eqStringImpl = refEq;

// output/Data.Eq/index.js
var eqString = {
  eq: eqStringImpl
};
var eqChar = {
  eq: eqCharImpl
};
var eq = function(dict) {
  return dict.eq;
};

// output/Data.Ordering/index.js
var LT = /* @__PURE__ */ (function() {
  function LT2() {
  }
  ;
  LT2.value = new LT2();
  return LT2;
})();
var GT = /* @__PURE__ */ (function() {
  function GT2() {
  }
  ;
  GT2.value = new GT2();
  return GT2;
})();
var EQ = /* @__PURE__ */ (function() {
  function EQ2() {
  }
  ;
  EQ2.value = new EQ2();
  return EQ2;
})();

// output/Data.Ring/foreign.js
var intSub = function(x) {
  return function(y) {
    return x - y | 0;
  };
};

// output/Data.Semiring/foreign.js
var intAdd = function(x) {
  return function(y) {
    return x + y | 0;
  };
};
var intMul = function(x) {
  return function(y) {
    return x * y | 0;
  };
};

// output/Data.Semiring/index.js
var semiringInt = {
  add: intAdd,
  zero: 0,
  mul: intMul,
  one: 1
};

// output/Data.Ring/index.js
var ringInt = {
  sub: intSub,
  Semiring0: function() {
    return semiringInt;
  }
};

// output/Data.Ord/index.js
var ordString = /* @__PURE__ */ (function() {
  return {
    compare: ordStringImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqString;
    }
  };
})();
var ordChar = /* @__PURE__ */ (function() {
  return {
    compare: ordCharImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqChar;
    }
  };
})();
var compare = function(dict) {
  return dict.compare;
};

// output/Data.Bounded/index.js
var top = function(dict) {
  return dict.top;
};
var boundedChar = {
  top: topChar,
  bottom: bottomChar,
  Ord0: function() {
    return ordChar;
  }
};
var bottom = function(dict) {
  return dict.bottom;
};

// output/Data.Show/foreign.js
var showIntImpl = function(n) {
  return n.toString();
};

// output/Data.Show/index.js
var showInt = {
  show: showIntImpl
};
var show = function(dict) {
  return dict.show;
};

// output/Data.Maybe/index.js
var identity2 = /* @__PURE__ */ identity(categoryFn);
var Nothing = /* @__PURE__ */ (function() {
  function Nothing2() {
  }
  ;
  Nothing2.value = new Nothing2();
  return Nothing2;
})();
var Just = /* @__PURE__ */ (function() {
  function Just2(value0) {
    this.value0 = value0;
  }
  ;
  Just2.create = function(value0) {
    return new Just2(value0);
  };
  return Just2;
})();
var maybe = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v;
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));
var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));
var functorMaybe = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof Just) {
        return new Just(v(v1.value0));
      }
      ;
      return Nothing.value;
    };
  }
};
var map2 = /* @__PURE__ */ map(functorMaybe);
var fromMaybe = function(a) {
  return maybe(a)(identity2);
};
var fromJust = function() {
  return function(v) {
    if (v instanceof Just) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v.constructor.name]);
  };
};
var applyMaybe = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return map2(v.value0)(v1);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var bindMaybe = {
  bind: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v1(v.value0);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Apply0: function() {
    return applyMaybe;
  }
};
var applicativeMaybe = /* @__PURE__ */ (function() {
  return {
    pure: Just.create,
    Apply0: function() {
      return applyMaybe;
    }
  };
})();

// output/Data.Either/index.js
var Left = /* @__PURE__ */ (function() {
  function Left2(value0) {
    this.value0 = value0;
  }
  ;
  Left2.create = function(value0) {
    return new Left2(value0);
  };
  return Left2;
})();
var Right = /* @__PURE__ */ (function() {
  function Right2(value0) {
    this.value0 = value0;
  }
  ;
  Right2.create = function(value0) {
    return new Right2(value0);
  };
  return Right2;
})();

// output/Data.EuclideanRing/foreign.js
var intDegree = function(x) {
  return Math.min(Math.abs(x), 2147483647);
};
var intDiv = function(x) {
  return function(y) {
    if (y === 0) return 0;
    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
  };
};
var intMod = function(x) {
  return function(y) {
    if (y === 0) return 0;
    var yy = Math.abs(y);
    return (x % yy + yy) % yy;
  };
};

// output/Data.CommutativeRing/index.js
var commutativeRingInt = {
  Ring0: function() {
    return ringInt;
  }
};

// output/Data.EuclideanRing/index.js
var mod = function(dict) {
  return dict.mod;
};
var euclideanRingInt = {
  degree: intDegree,
  div: intDiv,
  mod: intMod,
  CommutativeRing0: function() {
    return commutativeRingInt;
  }
};
var div = function(dict) {
  return dict.div;
};

// output/Data.Monoid/index.js
var monoidString = {
  mempty: "",
  Semigroup0: function() {
    return semigroupString;
  }
};
var mempty = function(dict) {
  return dict.mempty;
};

// output/Effect/foreign.js
var pureE = function(a) {
  return function() {
    return a;
  };
};
var bindE = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};

// output/Effect/index.js
var $runtime_lazy = function(name2, moduleName, init2) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name2 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init2();
    state2 = 2;
    return val;
  };
};
var monadEffect = {
  Applicative0: function() {
    return applicativeEffect;
  },
  Bind1: function() {
    return bindEffect;
  }
};
var bindEffect = {
  bind: bindE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var applicativeEffect = {
  pure: pureE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy("functorEffect", "Effect", function() {
  return {
    map: liftA1(applicativeEffect)
  };
});
var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy("applyEffect", "Effect", function() {
  return {
    apply: ap(monadEffect),
    Functor0: function() {
      return $lazy_functorEffect(0);
    }
  };
});
var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);

// output/Data.Foldable/foreign.js
var foldrArray = function(f) {
  return function(init2) {
    return function(xs) {
      var acc = init2;
      var len = xs.length;
      for (var i = len - 1; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };
};
var foldlArray = function(f) {
  return function(init2) {
    return function(xs) {
      var acc = init2;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
};

// output/Data.Tuple/index.js
var Tuple = /* @__PURE__ */ (function() {
  function Tuple2(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
  }
  ;
  Tuple2.create = function(value0) {
    return function(value1) {
      return new Tuple2(value0, value1);
    };
  };
  return Tuple2;
})();
var snd = function(v) {
  return v.value1;
};
var fst = function(v) {
  return v.value0;
};

// output/Unsafe.Coerce/foreign.js
var unsafeCoerce2 = function(x) {
  return x;
};

// output/Safe.Coerce/index.js
var coerce = function() {
  return unsafeCoerce2;
};

// output/Data.Foldable/index.js
var foldr = function(dict) {
  return dict.foldr;
};
var foldl = function(dict) {
  return dict.foldl;
};
var intercalate = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictMonoid) {
    var append2 = append(dictMonoid.Semigroup0());
    var mempty2 = mempty(dictMonoid);
    return function(sep2) {
      return function(xs) {
        var go = function(v) {
          return function(v1) {
            if (v.init) {
              return {
                init: false,
                acc: v1
              };
            }
            ;
            return {
              init: false,
              acc: append2(v.acc)(append2(sep2)(v1))
            };
          };
        };
        return foldl22(go)({
          init: true,
          acc: mempty2
        })(xs).acc;
      };
    };
  };
};
var foldMapDefaultR = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictMonoid) {
    var append2 = append(dictMonoid.Semigroup0());
    var mempty2 = mempty(dictMonoid);
    return function(f) {
      return foldr22(function(x) {
        return function(acc) {
          return append2(f(x))(acc);
        };
      })(mempty2);
    };
  };
};
var foldableArray = {
  foldr: foldrArray,
  foldl: foldlArray,
  foldMap: function(dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
  }
};
var foldMap = function(dict) {
  return dict.foldMap;
};

// output/Data.Function.Uncurried/foreign.js
var runFn2 = function(fn) {
  return function(a) {
    return function(b) {
      return fn(a, b);
    };
  };
};
var runFn3 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return fn(a, b, c);
      };
    };
  };
};
var runFn4 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function(d) {
          return fn(a, b, c, d);
        };
      };
    };
  };
};

// output/Data.FunctorWithIndex/foreign.js
var mapWithIndexArray = function(f) {
  return function(xs) {
    var l = xs.length;
    var result = Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(i)(xs[i]);
    }
    return result;
  };
};

// output/Data.FunctorWithIndex/index.js
var mapWithIndex = function(dict) {
  return dict.mapWithIndex;
};
var functorWithIndexArray = {
  mapWithIndex: mapWithIndexArray,
  Functor0: function() {
    return functorArray;
  }
};

// output/Data.Traversable/foreign.js
var traverseArrayImpl = /* @__PURE__ */ (function() {
  function array1(a) {
    return [a];
  }
  function array2(a) {
    return function(b) {
      return [a, b];
    };
  }
  function array3(a) {
    return function(b) {
      return function(c) {
        return [a, b, c];
      };
    };
  }
  function concat22(xs) {
    return function(ys) {
      return xs.concat(ys);
    };
  }
  return function(apply2) {
    return function(map13) {
      return function(pure7) {
        return function(f) {
          return function(array) {
            function go(bot, top2) {
              switch (top2 - bot) {
                case 0:
                  return pure7([]);
                case 1:
                  return map13(array1)(f(array[bot]));
                case 2:
                  return apply2(map13(array2)(f(array[bot])))(f(array[bot + 1]));
                case 3:
                  return apply2(apply2(map13(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                default:
                  var pivot = bot + Math.floor((top2 - bot) / 4) * 2;
                  return apply2(map13(concat22)(go(bot, pivot)))(go(pivot, top2));
              }
            }
            return go(0, array.length);
          };
        };
      };
    };
  };
})();

// output/Data.Traversable/index.js
var identity3 = /* @__PURE__ */ identity(categoryFn);
var traverse = function(dict) {
  return dict.traverse;
};
var sequenceDefault = function(dictTraversable) {
  var traverse22 = traverse(dictTraversable);
  return function(dictApplicative) {
    return traverse22(dictApplicative)(identity3);
  };
};
var traversableArray = {
  traverse: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));
  },
  sequence: function(dictApplicative) {
    return sequenceDefault(traversableArray)(dictApplicative);
  },
  Functor0: function() {
    return functorArray;
  },
  Foldable1: function() {
    return foldableArray;
  }
};

// output/Data.Unfoldable/foreign.js
var unfoldrArrayImpl = function(isNothing2) {
  return function(fromJust4) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value = b;
            while (true) {
              var maybe2 = f(value);
              if (isNothing2(maybe2)) return result;
              var tuple = fromJust4(maybe2);
              result.push(fst2(tuple));
              value = snd2(tuple);
            }
          };
        };
      };
    };
  };
};

// output/Data.Unfoldable1/foreign.js
var unfoldr1ArrayImpl = function(isNothing2) {
  return function(fromJust4) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value = b;
            while (true) {
              var tuple = f(value);
              result.push(fst2(tuple));
              var maybe2 = snd2(tuple);
              if (isNothing2(maybe2)) return result;
              value = fromJust4(maybe2);
            }
          };
        };
      };
    };
  };
};

// output/Data.Unfoldable1/index.js
var fromJust2 = /* @__PURE__ */ fromJust();
var unfoldable1Array = {
  unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)
};

// output/Data.Unfoldable/index.js
var fromJust3 = /* @__PURE__ */ fromJust();
var unfoldr = function(dict) {
  return dict.unfoldr;
};
var unfoldableArray = {
  unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust3)(fst)(snd),
  Unfoldable10: function() {
    return unfoldable1Array;
  }
};

// output/Data.Array/index.js
var intercalate1 = /* @__PURE__ */ intercalate(foldableArray);
var map3 = /* @__PURE__ */ map(functorMaybe);
var unsafeIndex = function() {
  return runFn2(unsafeIndexImpl);
};
var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();
var slice = /* @__PURE__ */ runFn3(sliceImpl);
var singleton2 = function(a) {
  return [a];
};
var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var intercalate2 = function(dictMonoid) {
  return intercalate1(dictMonoid);
};
var index = /* @__PURE__ */ (function() {
  return runFn4(indexImpl)(Just.create)(Nothing.value);
})();
var last = function(xs) {
  return index(xs)(length(xs) - 1 | 0);
};
var span = function(p) {
  return function(arr) {
    var go = function($copy_i) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(i) {
        var v = index(arr)(i);
        if (v instanceof Just) {
          var $156 = p(v.value0);
          if ($156) {
            $copy_i = i + 1 | 0;
            return;
          }
          ;
          $tco_done = true;
          return new Just(i);
        }
        ;
        if (v instanceof Nothing) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Array (line 1035, column 5 - line 1037, column 25): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_i);
      }
      ;
      return $tco_result;
    };
    var breakIndex = go(0);
    if (breakIndex instanceof Just && breakIndex.value0 === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    if (breakIndex instanceof Just) {
      return {
        init: slice(0)(breakIndex.value0)(arr),
        rest: slice(breakIndex.value0)(length(arr))(arr)
      };
    }
    ;
    if (breakIndex instanceof Nothing) {
      return {
        init: arr,
        rest: []
      };
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 1022, column 3 - line 1028, column 30): " + [breakIndex.constructor.name]);
  };
};
var takeWhile = function(p) {
  return function(xs) {
    return span(p)(xs).init;
  };
};
var head = function(xs) {
  return index(xs)(0);
};
var foldl2 = /* @__PURE__ */ foldl(foldableArray);
var findIndex = /* @__PURE__ */ (function() {
  return runFn4(findIndexImpl)(Just.create)(Nothing.value);
})();
var find2 = function(f) {
  return function(xs) {
    return map3(unsafeIndex1(xs))(findIndex(f)(xs));
  };
};
var filter = /* @__PURE__ */ runFn2(filterImpl);
var drop = function(n) {
  return function(xs) {
    var $173 = n < 1;
    if ($173) {
      return xs;
    }
    ;
    return slice(n)(length(xs))(xs);
  };
};
var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));
var mapMaybe = function(f) {
  return concatMap((function() {
    var $189 = maybe([])(singleton2);
    return function($190) {
      return $189(f($190));
    };
  })());
};
var catMaybes = /* @__PURE__ */ mapMaybe(/* @__PURE__ */ identity(categoryFn));
var any2 = /* @__PURE__ */ runFn2(anyImpl);

// output/Data.FoldableWithIndex/index.js
var foldrWithIndex = function(dict) {
  return dict.foldrWithIndex;
};

// output/Data.List.Types/index.js
var Nil = /* @__PURE__ */ (function() {
  function Nil2() {
  }
  ;
  Nil2.value = new Nil2();
  return Nil2;
})();
var Cons = /* @__PURE__ */ (function() {
  function Cons2(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
  }
  ;
  Cons2.create = function(value0) {
    return function(value1) {
      return new Cons2(value0, value1);
    };
  };
  return Cons2;
})();
var foldableList = {
  foldr: function(f) {
    return function(b) {
      var rev = (function() {
        var go = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 instanceof Nil) {
                $tco_done = true;
                return v;
              }
              ;
              if (v1 instanceof Cons) {
                $tco_var_v = new Cons(v1.value0, v);
                $copy_v1 = v1.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v.constructor.name, v1.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return go(Nil.value);
      })();
      var $284 = foldl(foldableList)(flip(f))(b);
      return function($285) {
        return $284(rev($285));
      };
    };
  },
  foldl: function(f) {
    var go = function($copy_b) {
      return function($copy_v) {
        var $tco_var_b = $copy_b;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(b, v) {
          if (v instanceof Nil) {
            $tco_done1 = true;
            return b;
          }
          ;
          if (v instanceof Cons) {
            $tco_var_b = f(b)(v.value0);
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_b, $copy_v);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append2 = append(dictMonoid.Semigroup0());
    var mempty2 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList)(function(acc) {
        var $286 = append2(acc);
        return function($287) {
          return $286(f($287));
        };
      })(mempty2);
    };
  }
};

// output/Data.Map.Internal/index.js
var $runtime_lazy2 = function(name2, moduleName, init2) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name2 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init2();
    state2 = 2;
    return val;
  };
};
var Leaf = /* @__PURE__ */ (function() {
  function Leaf2() {
  }
  ;
  Leaf2.value = new Leaf2();
  return Leaf2;
})();
var Node = /* @__PURE__ */ (function() {
  function Node2(value0, value1, value2, value3, value4, value5) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  Node2.create = function(value0) {
    return function(value1) {
      return function(value2) {
        return function(value3) {
          return function(value4) {
            return function(value5) {
              return new Node2(value0, value1, value2, value3, value4, value5);
            };
          };
        };
      };
    };
  };
  return Node2;
})();
var IterLeaf = /* @__PURE__ */ (function() {
  function IterLeaf2() {
  }
  ;
  IterLeaf2.value = new IterLeaf2();
  return IterLeaf2;
})();
var IterEmit = /* @__PURE__ */ (function() {
  function IterEmit2(value0, value1, value2) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }
  ;
  IterEmit2.create = function(value0) {
    return function(value1) {
      return function(value2) {
        return new IterEmit2(value0, value1, value2);
      };
    };
  };
  return IterEmit2;
})();
var IterNode = /* @__PURE__ */ (function() {
  function IterNode2(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
  }
  ;
  IterNode2.create = function(value0) {
    return function(value1) {
      return new IterNode2(value0, value1);
    };
  };
  return IterNode2;
})();
var Split = /* @__PURE__ */ (function() {
  function Split2(value0, value1, value2) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }
  ;
  Split2.create = function(value0) {
    return function(value1) {
      return function(value2) {
        return new Split2(value0, value1, value2);
      };
    };
  };
  return Split2;
})();
var SplitLast = /* @__PURE__ */ (function() {
  function SplitLast2(value0, value1, value2) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }
  ;
  SplitLast2.create = function(value0) {
    return function(value1) {
      return function(value2) {
        return new SplitLast2(value0, value1, value2);
      };
    };
  };
  return SplitLast2;
})();
var unsafeNode = function(k, v, l, r) {
  if (l instanceof Leaf) {
    if (r instanceof Leaf) {
      return new Node(1, 1, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + r.value0 | 0, 1 + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 702, column 5 - line 706, column 39): " + [r.constructor.name]);
  }
  ;
  if (l instanceof Node) {
    if (r instanceof Leaf) {
      return new Node(1 + l.value0 | 0, 1 + l.value1 | 0, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + (function() {
        var $280 = l.value0 > r.value0;
        if ($280) {
          return l.value0;
        }
        ;
        return r.value0;
      })() | 0, (1 + l.value1 | 0) + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 708, column 5 - line 712, column 68): " + [r.constructor.name]);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 700, column 32 - line 712, column 68): " + [l.constructor.name]);
};
var toMapIter = /* @__PURE__ */ (function() {
  return flip(IterNode.create)(IterLeaf.value);
})();
var stepWith = function(f) {
  return function(next) {
    return function(done) {
      var go = function($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v) {
          if (v instanceof IterLeaf) {
            $tco_done = true;
            return done(unit);
          }
          ;
          if (v instanceof IterEmit) {
            $tco_done = true;
            return next(v.value0, v.value1, v.value2);
          }
          ;
          if (v instanceof IterNode) {
            $copy_v = f(v.value1)(v.value0);
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 940, column 8 - line 946, column 20): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_v);
        }
        ;
        return $tco_result;
      };
      return go;
    };
  };
};
var size = function(v) {
  if (v instanceof Leaf) {
    return 0;
  }
  ;
  if (v instanceof Node) {
    return v.value1;
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 618, column 8 - line 620, column 24): " + [v.constructor.name]);
};
var singleton4 = function(k) {
  return function(v) {
    return new Node(1, 1, k, v, Leaf.value, Leaf.value);
  };
};
var unsafeBalancedNode = /* @__PURE__ */ (function() {
  var height = function(v) {
    if (v instanceof Leaf) {
      return 0;
    }
    ;
    if (v instanceof Node) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 757, column 12 - line 759, column 26): " + [v.constructor.name]);
  };
  var rotateLeft = function(k, v, l, rk, rv, rl, rr) {
    if (rl instanceof Node && rl.value0 > height(rr)) {
      return unsafeNode(rl.value2, rl.value3, unsafeNode(k, v, l, rl.value4), unsafeNode(rk, rv, rl.value5, rr));
    }
    ;
    return unsafeNode(rk, rv, unsafeNode(k, v, l, rl), rr);
  };
  var rotateRight = function(k, v, lk, lv, ll, lr, r) {
    if (lr instanceof Node && height(ll) <= lr.value0) {
      return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k, v, lr.value5, r));
    }
    ;
    return unsafeNode(lk, lv, ll, unsafeNode(k, v, lr, r));
  };
  return function(k, v, l, r) {
    if (l instanceof Leaf) {
      if (r instanceof Leaf) {
        return singleton4(k)(v);
      }
      ;
      if (r instanceof Node && r.value0 > 1) {
        return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    if (l instanceof Node) {
      if (r instanceof Node) {
        if (r.value0 > (l.value0 + 1 | 0)) {
          return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
        }
        ;
        if (l.value0 > (r.value0 + 1 | 0)) {
          return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
        }
        ;
      }
      ;
      if (r instanceof Leaf && l.value0 > 1) {
        return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 717, column 40 - line 738, column 34): " + [l.constructor.name]);
  };
})();
var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy2("unsafeSplit", "Data.Map.Internal", function() {
  return function(comp, k, m) {
    if (m instanceof Leaf) {
      return new Split(Nothing.value, Leaf.value, Leaf.value);
    }
    ;
    if (m instanceof Node) {
      var v = comp(k)(m.value2);
      if (v instanceof LT) {
        var v1 = $lazy_unsafeSplit(793)(comp, k, m.value4);
        return new Split(v1.value0, v1.value1, unsafeBalancedNode(m.value2, m.value3, v1.value2, m.value5));
      }
      ;
      if (v instanceof GT) {
        var v1 = $lazy_unsafeSplit(796)(comp, k, m.value5);
        return new Split(v1.value0, unsafeBalancedNode(m.value2, m.value3, m.value4, v1.value1), v1.value2);
      }
      ;
      if (v instanceof EQ) {
        return new Split(new Just(m.value3), m.value4, m.value5);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 791, column 5 - line 799, column 30): " + [v.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 787, column 34 - line 799, column 30): " + [m.constructor.name]);
  };
});
var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(786);
var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy2("unsafeSplitLast", "Data.Map.Internal", function() {
  return function(k, v, l, r) {
    if (r instanceof Leaf) {
      return new SplitLast(k, v, l);
    }
    ;
    if (r instanceof Node) {
      var v1 = $lazy_unsafeSplitLast(779)(r.value2, r.value3, r.value4, r.value5);
      return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k, v, l, v1.value2));
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 776, column 37 - line 780, column 57): " + [r.constructor.name]);
  };
});
var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(775);
var unsafeJoinNodes = function(v, v1) {
  if (v instanceof Leaf) {
    return v1;
  }
  ;
  if (v instanceof Node) {
    var v2 = unsafeSplitLast(v.value2, v.value3, v.value4, v.value5);
    return unsafeBalancedNode(v2.value0, v2.value1, v2.value2, v1);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 764, column 25 - line 768, column 38): " + [v.constructor.name, v1.constructor.name]);
};
var $lazy_unsafeDifference = /* @__PURE__ */ $runtime_lazy2("unsafeDifference", "Data.Map.Internal", function() {
  return function(comp, l, r) {
    if (l instanceof Leaf) {
      return Leaf.value;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeDifference(841)(comp, v.value1, r.value4);
      var r$prime = $lazy_unsafeDifference(842)(comp, v.value2, r.value5);
      return unsafeJoinNodes(l$prime, r$prime);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 836, column 39 - line 843, column 33): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeDifference = /* @__PURE__ */ $lazy_unsafeDifference(835);
var $lazy_unsafeUnionWith = /* @__PURE__ */ $runtime_lazy2("unsafeUnionWith", "Data.Map.Internal", function() {
  return function(comp, app, l, r) {
    if (l instanceof Leaf) {
      return r;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeUnionWith(809)(comp, app, v.value1, r.value4);
      var r$prime = $lazy_unsafeUnionWith(810)(comp, app, v.value2, r.value5);
      if (v.value0 instanceof Just) {
        return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);
      }
      ;
      if (v.value0 instanceof Nothing) {
        return unsafeBalancedNode(r.value2, r.value3, l$prime, r$prime);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 811, column 5 - line 815, column 46): " + [v.value0.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 804, column 42 - line 815, column 46): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeUnionWith = /* @__PURE__ */ $lazy_unsafeUnionWith(803);
var unionWith = function(dictOrd) {
  var compare2 = compare(dictOrd);
  return function(app) {
    return function(m1) {
      return function(m2) {
        return unsafeUnionWith(compare2, app, m1, m2);
      };
    };
  };
};
var union = function(dictOrd) {
  return unionWith(dictOrd)($$const);
};
var lookup = function(dictOrd) {
  var compare2 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare2(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value3);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 283, column 7 - line 286, column 22): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 280, column 8 - line 286, column 22): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var iterMapL = /* @__PURE__ */ (function() {
  var go = function($copy_iter) {
    return function($copy_v) {
      var $tco_var_iter = $copy_iter;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(iter, v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return iter;
        }
        ;
        if (v instanceof Node) {
          if (v.value5 instanceof Leaf) {
            $tco_var_iter = new IterEmit(v.value2, v.value3, iter);
            $copy_v = v.value4;
            return;
          }
          ;
          $tco_var_iter = new IterEmit(v.value2, v.value3, new IterNode(v.value5, iter));
          $copy_v = v.value4;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 951, column 13 - line 958, column 48): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_iter, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  return go;
})();
var stepAscCps = /* @__PURE__ */ stepWith(iterMapL);
var stepUnfoldr = /* @__PURE__ */ (function() {
  var step = function(k, v, next) {
    return new Just(new Tuple(new Tuple(k, v), next));
  };
  return stepAscCps(step)(function(v) {
    return Nothing.value;
  });
})();
var toUnfoldable = function(dictUnfoldable) {
  var $784 = unfoldr(dictUnfoldable)(stepUnfoldr);
  return function($785) {
    return $784(toMapIter($785));
  };
};
var isEmpty = function(v) {
  if (v instanceof Leaf) {
    return true;
  }
  ;
  return false;
};
var insertWith = function(dictOrd) {
  var compare2 = compare(dictOrd);
  return function(app) {
    return function(k) {
      return function(v) {
        var go = function(v1) {
          if (v1 instanceof Leaf) {
            return singleton4(k)(v);
          }
          ;
          if (v1 instanceof Node) {
            var v2 = compare2(k)(v1.value2);
            if (v2 instanceof LT) {
              return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
            }
            ;
            if (v2 instanceof GT) {
              return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
            }
            ;
            if (v2 instanceof EQ) {
              return new Node(v1.value0, v1.value1, k, app(v1.value3)(v), v1.value4, v1.value5);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 486, column 7 - line 489, column 44): " + [v2.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 483, column 8 - line 489, column 44): " + [v1.constructor.name]);
        };
        return go;
      };
    };
  };
};
var insert = function(dictOrd) {
  var compare2 = compare(dictOrd);
  return function(k) {
    return function(v) {
      var go = function(v1) {
        if (v1 instanceof Leaf) {
          return singleton4(k)(v);
        }
        ;
        if (v1 instanceof Node) {
          var v2 = compare2(k)(v1.value2);
          if (v2 instanceof LT) {
            return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
          }
          ;
          if (v2 instanceof GT) {
            return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
          }
          ;
          if (v2 instanceof EQ) {
            return new Node(v1.value0, v1.value1, k, v, v1.value4, v1.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 471, column 7 - line 474, column 35): " + [v2.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 468, column 8 - line 474, column 35): " + [v1.constructor.name]);
      };
      return go;
    };
  };
};
var functorMap = {
  map: function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        return new Node(v.value0, v.value1, v.value2, f(v.value3), go(v.value4), go(v.value5));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 147, column 10 - line 150, column 39): " + [v.constructor.name]);
    };
    return go;
  }
};
var foldableMap = {
  foldr: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy2("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(172)(m$prime.value4, f(m$prime.value3)($lazy_go(172)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 169, column 26 - line 172, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(169);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy2("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(178)(f($lazy_go(178)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 175, column 26 - line 178, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(175);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty2 = mempty(dictMonoid);
    var append13 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty2;
        }
        ;
        if (v instanceof Node) {
          return append13(go(v.value4))(append13(f(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 181, column 10 - line 184, column 28): " + [v.constructor.name]);
      };
      return go;
    };
  }
};
var foldableWithIndexMap = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy2("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(192)(m$prime.value4, f(m$prime.value2)(m$prime.value3)($lazy_go(192)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 189, column 26 - line 192, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(189);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy2("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(198)(f(m$prime.value2)($lazy_go(198)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 195, column 26 - line 198, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(195);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    var mempty2 = mempty(dictMonoid);
    var append13 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty2;
        }
        ;
        if (v instanceof Node) {
          return append13(go(v.value4))(append13(f(v.value2)(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 201, column 10 - line 204, column 30): " + [v.constructor.name]);
      };
      return go;
    };
  },
  Foldable0: function() {
    return foldableMap;
  }
};
var keys = /* @__PURE__ */ (function() {
  return foldrWithIndex(foldableWithIndexMap)(function(k) {
    return function(v) {
      return function(acc) {
        return new Cons(k, acc);
      };
    };
  })(Nil.value);
})();
var empty2 = /* @__PURE__ */ (function() {
  return Leaf.value;
})();
var fromFoldable = function(dictOrd) {
  var insert1 = insert(dictOrd);
  return function(dictFoldable) {
    return foldl(dictFoldable)(function(m) {
      return function(v) {
        return insert1(v.value0)(v.value1)(m);
      };
    })(empty2);
  };
};
var difference = function(dictOrd) {
  var compare2 = compare(dictOrd);
  return function(m1) {
    return function(m2) {
      return unsafeDifference(compare2, m1, m2);
    };
  };
};

// output/Data.List/index.js
var map4 = /* @__PURE__ */ map(functorMaybe);
var uncons = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just({
      head: v.value0,
      tail: v.value1
    });
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 259, column 1 - line 259, column 66): " + [v.constructor.name]);
};
var toUnfoldable2 = function(dictUnfoldable) {
  return unfoldr(dictUnfoldable)(function(xs) {
    return map4(function(rec) {
      return new Tuple(rec.head, rec.tail);
    })(uncons(xs));
  });
};

// output/Data.Set/index.js
var coerce2 = /* @__PURE__ */ coerce();
var foldMap2 = /* @__PURE__ */ foldMap(foldableList);
var foldl3 = /* @__PURE__ */ foldl(foldableList);
var foldr2 = /* @__PURE__ */ foldr(foldableList);
var $$Set = function(x) {
  return x;
};
var union2 = function(dictOrd) {
  return coerce2(union(dictOrd));
};
var toList = function(v) {
  return keys(v);
};
var toUnfoldable3 = function(dictUnfoldable) {
  var $96 = toUnfoldable2(dictUnfoldable);
  return function($97) {
    return $96(toList($97));
  };
};
var size2 = /* @__PURE__ */ coerce2(size);
var singleton5 = function(a) {
  return singleton4(a)(unit);
};
var isEmpty2 = /* @__PURE__ */ coerce2(isEmpty);
var insert2 = function(dictOrd) {
  var insert1 = insert(dictOrd);
  return function(a) {
    return function(v) {
      return insert1(a)(unit)(v);
    };
  };
};
var fromMap = $$Set;
var foldableSet = {
  foldMap: function(dictMonoid) {
    var foldMap12 = foldMap2(dictMonoid);
    return function(f) {
      var $98 = foldMap12(f);
      return function($99) {
        return $98(toList($99));
      };
    };
  },
  foldl: function(f) {
    return function(x) {
      var $100 = foldl3(f)(x);
      return function($101) {
        return $100(toList($101));
      };
    };
  },
  foldr: function(f) {
    return function(x) {
      var $102 = foldr2(f)(x);
      return function($103) {
        return $102(toList($103));
      };
    };
  }
};
var empty3 = empty2;
var fromFoldable2 = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictOrd) {
    var insert1 = insert2(dictOrd);
    return foldl22(function(m) {
      return function(a) {
        return insert1(a)(m);
      };
    })(empty3);
  };
};
var difference2 = function(dictOrd) {
  return coerce2(difference(dictOrd));
};

// output/Data.Map/index.js
var keys2 = /* @__PURE__ */ (function() {
  var $38 = $$void(functorMap);
  return function($39) {
    return fromMap($38($39));
  };
})();

// output/Data.String.CodePoints/foreign.js
var hasArrayFrom = typeof Array.from === "function";
var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
var hasCodePointAt = typeof String.prototype.codePointAt === "function";
var _unsafeCodePointAt0 = function(fallback) {
  return hasCodePointAt ? function(str) {
    return str.codePointAt(0);
  } : fallback;
};
var _fromCodePointArray = function(singleton9) {
  return hasFromCodePoint ? function(cps) {
    if (cps.length < 1e4) {
      return String.fromCodePoint.apply(String, cps);
    }
    return cps.map(singleton9).join("");
  } : function(cps) {
    return cps.map(singleton9).join("");
  };
};
var _singleton = function(fallback) {
  return hasFromCodePoint ? String.fromCodePoint : fallback;
};
var _take = function(fallback) {
  return function(n) {
    if (hasStringIterator) {
      return function(str) {
        var accum = "";
        var iter = str[Symbol.iterator]();
        for (var i = 0; i < n; ++i) {
          var o = iter.next();
          if (o.done) return accum;
          accum += o.value;
        }
        return accum;
      };
    }
    return fallback(n);
  };
};
var _toCodePointArray = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasArrayFrom) {
      return function(str) {
        return Array.from(str, unsafeCodePointAt02);
      };
    }
    return fallback;
  };
};

// output/Data.Enum/foreign.js
function toCharCode(c) {
  return c.charCodeAt(0);
}
function fromCharCode(c) {
  return String.fromCharCode(c);
}

// output/Data.Enum/index.js
var bottom1 = /* @__PURE__ */ bottom(boundedChar);
var top1 = /* @__PURE__ */ top(boundedChar);
var toEnum = function(dict) {
  return dict.toEnum;
};
var fromEnum = function(dict) {
  return dict.fromEnum;
};
var toEnumWithDefaults = function(dictBoundedEnum) {
  var toEnum1 = toEnum(dictBoundedEnum);
  var fromEnum1 = fromEnum(dictBoundedEnum);
  var bottom2 = bottom(dictBoundedEnum.Bounded0());
  return function(low) {
    return function(high) {
      return function(x) {
        var v = toEnum1(x);
        if (v instanceof Just) {
          return v.value0;
        }
        ;
        if (v instanceof Nothing) {
          var $140 = x < fromEnum1(bottom2);
          if ($140) {
            return low;
          }
          ;
          return high;
        }
        ;
        throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [v.constructor.name]);
      };
    };
  };
};
var defaultSucc = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) + 1 | 0);
    };
  };
};
var defaultPred = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) - 1 | 0);
    };
  };
};
var charToEnum = function(v) {
  if (v >= toCharCode(bottom1) && v <= toCharCode(top1)) {
    return new Just(fromCharCode(v));
  }
  ;
  return Nothing.value;
};
var enumChar = {
  succ: /* @__PURE__ */ defaultSucc(charToEnum)(toCharCode),
  pred: /* @__PURE__ */ defaultPred(charToEnum)(toCharCode),
  Ord0: function() {
    return ordChar;
  }
};
var boundedEnumChar = /* @__PURE__ */ (function() {
  return {
    cardinality: toCharCode(top1) - toCharCode(bottom1) | 0,
    toEnum: charToEnum,
    fromEnum: toCharCode,
    Bounded0: function() {
      return boundedChar;
    },
    Enum1: function() {
      return enumChar;
    }
  };
})();

// output/Data.String.CodeUnits/foreign.js
var singleton6 = function(c) {
  return c;
};
var length2 = function(s) {
  return s.length;
};
var _indexOf = function(just) {
  return function(nothing) {
    return function(x) {
      return function(s) {
        var i = s.indexOf(x);
        return i === -1 ? nothing : just(i);
      };
    };
  };
};
var take = function(n) {
  return function(s) {
    return s.substr(0, n);
  };
};
var drop2 = function(n) {
  return function(s) {
    return s.substring(n);
  };
};

// output/Data.String.Unsafe/foreign.js
var charAt = function(i) {
  return function(s) {
    if (i >= 0 && i < s.length) return s.charAt(i);
    throw new Error("Data.String.Unsafe.charAt: Invalid index.");
  };
};

// output/Data.String.CodeUnits/index.js
var indexOf = /* @__PURE__ */ (function() {
  return _indexOf(Just.create)(Nothing.value);
})();
var contains = function(pat) {
  var $23 = indexOf(pat);
  return function($24) {
    return isJust($23($24));
  };
};

// output/Data.String.Common/foreign.js
var split = function(sep2) {
  return function(s) {
    return s.split(sep2);
  };
};
var trim = function(s) {
  return s.trim();
};
var joinWith = function(s) {
  return function(xs) {
    return xs.join(s);
  };
};

// output/Data.String.Common/index.js
var $$null = function(s) {
  return s === "";
};

// output/Data.String.CodePoints/index.js
var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var map5 = /* @__PURE__ */ map(functorMaybe);
var unfoldr2 = /* @__PURE__ */ unfoldr(unfoldableArray);
var div2 = /* @__PURE__ */ div(euclideanRingInt);
var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
var CodePoint = function(x) {
  return x;
};
var unsurrogate = function(lead) {
  return function(trail) {
    return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
  };
};
var isTrail = function(cu) {
  return 56320 <= cu && cu <= 57343;
};
var isLead = function(cu) {
  return 55296 <= cu && cu <= 56319;
};
var uncons2 = function(s) {
  var v = length2(s);
  if (v === 0) {
    return Nothing.value;
  }
  ;
  if (v === 1) {
    return new Just({
      head: fromEnum2(charAt(0)(s)),
      tail: ""
    });
  }
  ;
  var cu1 = fromEnum2(charAt(1)(s));
  var cu0 = fromEnum2(charAt(0)(s));
  var $43 = isLead(cu0) && isTrail(cu1);
  if ($43) {
    return new Just({
      head: unsurrogate(cu0)(cu1),
      tail: drop2(2)(s)
    });
  }
  ;
  return new Just({
    head: cu0,
    tail: drop2(1)(s)
  });
};
var unconsButWithTuple = function(s) {
  return map5(function(v) {
    return new Tuple(v.head, v.tail);
  })(uncons2(s));
};
var toCodePointArrayFallback = function(s) {
  return unfoldr2(unconsButWithTuple)(s);
};
var unsafeCodePointAt0Fallback = function(s) {
  var cu0 = fromEnum2(charAt(0)(s));
  var $47 = isLead(cu0) && length2(s) > 1;
  if ($47) {
    var cu1 = fromEnum2(charAt(1)(s));
    var $48 = isTrail(cu1);
    if ($48) {
      return unsurrogate(cu0)(cu1);
    }
    ;
    return cu0;
  }
  ;
  return cu0;
};
var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
var length3 = function($74) {
  return length(toCodePointArray($74));
};
var indexOf2 = function(p) {
  return function(s) {
    return map5(function(i) {
      return length3(take(i)(s));
    })(indexOf(p)(s));
  };
};
var fromCharCode2 = /* @__PURE__ */ (function() {
  var $75 = toEnumWithDefaults(boundedEnumChar)(bottom(boundedChar))(top(boundedChar));
  return function($76) {
    return singleton6($75($76));
  };
})();
var singletonFallback = function(v) {
  if (v <= 65535) {
    return fromCharCode2(v);
  }
  ;
  var lead = div2(v - 65536 | 0)(1024) + 55296 | 0;
  var trail = mod2(v - 65536 | 0)(1024) + 56320 | 0;
  return fromCharCode2(lead) + fromCharCode2(trail);
};
var fromCodePointArray = /* @__PURE__ */ _fromCodePointArray(singletonFallback);
var singleton7 = /* @__PURE__ */ _singleton(singletonFallback);
var takeFallback = function(v) {
  return function(v1) {
    if (v < 1) {
      return "";
    }
    ;
    var v2 = uncons2(v1);
    if (v2 instanceof Just) {
      return singleton7(v2.value0.head) + takeFallback(v - 1 | 0)(v2.value0.tail);
    }
    ;
    return v1;
  };
};
var take2 = /* @__PURE__ */ _take(takeFallback);
var eqCodePoint = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var drop3 = function(n) {
  return function(s) {
    return drop2(length2(take2(n)(s)))(s);
  };
};
var codePointFromChar = function($77) {
  return CodePoint(fromEnum2($77));
};

// output/Effect.Aff/foreign.js
var Aff = (function() {
  var EMPTY = {};
  var PURE = "Pure";
  var THROW = "Throw";
  var CATCH = "Catch";
  var SYNC = "Sync";
  var ASYNC = "Async";
  var BIND = "Bind";
  var BRACKET = "Bracket";
  var FORK = "Fork";
  var SEQ = "Sequential";
  var MAP = "Map";
  var APPLY = "Apply";
  var ALT = "Alt";
  var CONS = "Cons";
  var RESUME = "Resume";
  var RELEASE = "Release";
  var FINALIZER = "Finalizer";
  var FINALIZED = "Finalized";
  var FORKED = "Forked";
  var FIBER = "Fiber";
  var THUNK = "Thunk";
  function Aff2(tag, _1, _2, _3) {
    this.tag = tag;
    this._1 = _1;
    this._2 = _2;
    this._3 = _3;
  }
  function AffCtr(tag) {
    var fn = function(_1, _2, _3) {
      return new Aff2(tag, _1, _2, _3);
    };
    fn.tag = tag;
    return fn;
  }
  function nonCanceler(error3) {
    return new Aff2(PURE, void 0);
  }
  function runEff(eff) {
    try {
      eff();
    } catch (error3) {
      setTimeout(function() {
        throw error3;
      }, 0);
    }
  }
  function runSync(left, right, eff) {
    try {
      return right(eff());
    } catch (error3) {
      return left(error3);
    }
  }
  function runAsync(left, eff, k) {
    try {
      return eff(k)();
    } catch (error3) {
      k(left(error3))();
      return nonCanceler;
    }
  }
  var Scheduler = (function() {
    var limit = 1024;
    var size6 = 0;
    var ix = 0;
    var queue = new Array(limit);
    var draining = false;
    function drain() {
      var thunk;
      draining = true;
      while (size6 !== 0) {
        size6--;
        thunk = queue[ix];
        queue[ix] = void 0;
        ix = (ix + 1) % limit;
        thunk();
      }
      draining = false;
    }
    return {
      isDraining: function() {
        return draining;
      },
      enqueue: function(cb) {
        var i, tmp;
        if (size6 === limit) {
          tmp = draining;
          drain();
          draining = tmp;
        }
        queue[(ix + size6) % limit] = cb;
        size6++;
        if (!draining) {
          drain();
        }
      }
    };
  })();
  function Supervisor(util) {
    var fibers = {};
    var fiberId = 0;
    var count = 0;
    return {
      register: function(fiber) {
        var fid = fiberId++;
        fiber.onComplete({
          rethrow: true,
          handler: function(result) {
            return function() {
              count--;
              delete fibers[fid];
            };
          }
        })();
        fibers[fid] = fiber;
        count++;
      },
      isEmpty: function() {
        return count === 0;
      },
      killAll: function(killError, cb) {
        return function() {
          if (count === 0) {
            return cb();
          }
          var killCount = 0;
          var kills = {};
          function kill(fid) {
            kills[fid] = fibers[fid].kill(killError, function(result) {
              return function() {
                delete kills[fid];
                killCount--;
                if (util.isLeft(result) && util.fromLeft(result)) {
                  setTimeout(function() {
                    throw util.fromLeft(result);
                  }, 0);
                }
                if (killCount === 0) {
                  cb();
                }
              };
            })();
          }
          for (var k in fibers) {
            if (fibers.hasOwnProperty(k)) {
              killCount++;
              kill(k);
            }
          }
          fibers = {};
          fiberId = 0;
          count = 0;
          return function(error3) {
            return new Aff2(SYNC, function() {
              for (var k2 in kills) {
                if (kills.hasOwnProperty(k2)) {
                  kills[k2]();
                }
              }
            });
          };
        };
      }
    };
  }
  var SUSPENDED = 0;
  var CONTINUE = 1;
  var STEP_BIND = 2;
  var STEP_RESULT = 3;
  var PENDING = 4;
  var RETURN = 5;
  var COMPLETED = 6;
  function Fiber(util, supervisor, aff) {
    var runTick = 0;
    var status = SUSPENDED;
    var step = aff;
    var fail = null;
    var interrupt = null;
    var bhead = null;
    var btail = null;
    var attempts = null;
    var bracketCount = 0;
    var joinId = 0;
    var joins = null;
    var rethrow = true;
    function run3(localRunTick) {
      var tmp, result, attempt2;
      while (true) {
        tmp = null;
        result = null;
        attempt2 = null;
        switch (status) {
          case STEP_BIND:
            status = CONTINUE;
            try {
              step = bhead(step);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status = RETURN;
              fail = util.left(e);
              step = null;
            }
            break;
          case STEP_RESULT:
            if (util.isLeft(step)) {
              status = RETURN;
              fail = step;
              step = null;
            } else if (bhead === null) {
              status = RETURN;
            } else {
              status = STEP_BIND;
              step = util.fromRight(step);
            }
            break;
          case CONTINUE:
            switch (step.tag) {
              case BIND:
                if (bhead) {
                  btail = new Aff2(CONS, bhead, btail);
                }
                bhead = step._2;
                status = CONTINUE;
                step = step._1;
                break;
              case PURE:
                if (bhead === null) {
                  status = RETURN;
                  step = util.right(step._1);
                } else {
                  status = STEP_BIND;
                  step = step._1;
                }
                break;
              case SYNC:
                status = STEP_RESULT;
                step = runSync(util.left, util.right, step._1);
                break;
              case ASYNC:
                status = PENDING;
                step = runAsync(util.left, step._1, function(result2) {
                  return function() {
                    if (runTick !== localRunTick) {
                      return;
                    }
                    runTick++;
                    Scheduler.enqueue(function() {
                      if (runTick !== localRunTick + 1) {
                        return;
                      }
                      status = STEP_RESULT;
                      step = result2;
                      run3(runTick);
                    });
                  };
                });
                return;
              case THROW:
                status = RETURN;
                fail = util.left(step._1);
                step = null;
                break;
              // Enqueue the Catch so that we can call the error handler later on
              // in case of an exception.
              case CATCH:
                if (bhead === null) {
                  attempts = new Aff2(CONS, step, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step = step._1;
                break;
              // Enqueue the Bracket so that we can call the appropriate handlers
              // after resource acquisition.
              case BRACKET:
                bracketCount++;
                if (bhead === null) {
                  attempts = new Aff2(CONS, step, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step = step._1;
                break;
              case FORK:
                status = STEP_RESULT;
                tmp = Fiber(util, supervisor, step._2);
                if (supervisor) {
                  supervisor.register(tmp);
                }
                if (step._1) {
                  tmp.run();
                }
                step = util.right(tmp);
                break;
              case SEQ:
                status = CONTINUE;
                step = sequential2(util, supervisor, step._1);
                break;
            }
            break;
          case RETURN:
            bhead = null;
            btail = null;
            if (attempts === null) {
              status = COMPLETED;
              step = interrupt || fail || step;
            } else {
              tmp = attempts._3;
              attempt2 = attempts._1;
              attempts = attempts._2;
              switch (attempt2.tag) {
                // We cannot recover from an unmasked interrupt. Otherwise we should
                // continue stepping, or run the exception handler if an exception
                // was raised.
                case CATCH:
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    status = RETURN;
                  } else if (fail) {
                    status = CONTINUE;
                    step = attempt2._2(util.fromLeft(fail));
                    fail = null;
                  }
                  break;
                // We cannot resume from an unmasked interrupt or exception.
                case RESUME:
                  if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {
                    status = RETURN;
                  } else {
                    bhead = attempt2._1;
                    btail = attempt2._2;
                    status = STEP_BIND;
                    step = util.fromRight(step);
                  }
                  break;
                // If we have a bracket, we should enqueue the handlers,
                // and continue with the success branch only if the fiber has
                // not been interrupted. If the bracket acquisition failed, we
                // should not run either.
                case BRACKET:
                  bracketCount--;
                  if (fail === null) {
                    result = util.fromRight(step);
                    attempts = new Aff2(CONS, new Aff2(RELEASE, attempt2._2, result), attempts, tmp);
                    if (interrupt === tmp || bracketCount > 0) {
                      status = CONTINUE;
                      step = attempt2._3(result);
                    }
                  }
                  break;
                // Enqueue the appropriate handler. We increase the bracket count
                // because it should not be cancelled.
                case RELEASE:
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step, fail), attempts, interrupt);
                  status = CONTINUE;
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    step = attempt2._1.killed(util.fromLeft(interrupt))(attempt2._2);
                  } else if (fail) {
                    step = attempt2._1.failed(util.fromLeft(fail))(attempt2._2);
                  } else {
                    step = attempt2._1.completed(util.fromRight(step))(attempt2._2);
                  }
                  fail = null;
                  bracketCount++;
                  break;
                case FINALIZER:
                  bracketCount++;
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step, fail), attempts, interrupt);
                  status = CONTINUE;
                  step = attempt2._1;
                  break;
                case FINALIZED:
                  bracketCount--;
                  status = RETURN;
                  step = attempt2._1;
                  fail = attempt2._2;
                  break;
              }
            }
            break;
          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step));
              }
            }
            joins = null;
            if (interrupt && fail) {
              setTimeout(function() {
                throw util.fromLeft(fail);
              }, 0);
            } else if (util.isLeft(step) && rethrow) {
              setTimeout(function() {
                if (rethrow) {
                  throw util.fromLeft(step);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status = CONTINUE;
            break;
          case PENDING:
            return;
        }
      }
    }
    function onComplete(join3) {
      return function() {
        if (status === COMPLETED) {
          rethrow = rethrow && join3.rethrow;
          join3.handler(step)();
          return function() {
          };
        }
        var jid = joinId++;
        joins = joins || {};
        joins[jid] = join3;
        return function() {
          if (joins !== null) {
            delete joins[jid];
          }
        };
      };
    }
    function kill(error3, cb) {
      return function() {
        if (status === COMPLETED) {
          cb(util.right(void 0))();
          return function() {
          };
        }
        var canceler = onComplete({
          rethrow: false,
          handler: function() {
            return cb(util.right(void 0));
          }
        })();
        switch (status) {
          case SUSPENDED:
            interrupt = util.left(error3);
            status = COMPLETED;
            step = interrupt;
            run3(runTick);
            break;
          case PENDING:
            if (interrupt === null) {
              interrupt = util.left(error3);
            }
            if (bracketCount === 0) {
              if (status === PENDING) {
                attempts = new Aff2(CONS, new Aff2(FINALIZER, step(error3)), attempts, interrupt);
              }
              status = RETURN;
              step = null;
              fail = null;
              run3(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error3);
            }
            if (bracketCount === 0) {
              status = RETURN;
              step = null;
              fail = null;
            }
        }
        return canceler;
      };
    }
    function join2(cb) {
      return function() {
        var canceler = onComplete({
          rethrow: false,
          handler: cb
        })();
        if (status === SUSPENDED) {
          run3(runTick);
        }
        return canceler;
      };
    }
    return {
      kill,
      join: join2,
      onComplete,
      isSuspended: function() {
        return status === SUSPENDED;
      },
      run: function() {
        if (status === SUSPENDED) {
          if (!Scheduler.isDraining()) {
            Scheduler.enqueue(function() {
              run3(runTick);
            });
          } else {
            run3(runTick);
          }
        }
      }
    };
  }
  function runPar(util, supervisor, par, cb) {
    var fiberId = 0;
    var fibers = {};
    var killId = 0;
    var kills = {};
    var early = new Error("[ParAff] Early exit");
    var interrupt = null;
    var root = EMPTY;
    function kill(error3, par2, cb2) {
      var step = par2;
      var head2 = null;
      var tail = null;
      var count = 0;
      var kills2 = {};
      var tmp, kid;
      loop: while (true) {
        tmp = null;
        switch (step.tag) {
          case FORKED:
            if (step._3 === EMPTY) {
              tmp = fibers[step._1];
              kills2[count++] = tmp.kill(error3, function(result) {
                return function() {
                  count--;
                  if (count === 0) {
                    cb2(result)();
                  }
                };
              });
            }
            if (head2 === null) {
              break loop;
            }
            step = head2._2;
            if (tail === null) {
              head2 = null;
            } else {
              head2 = tail._1;
              tail = tail._2;
            }
            break;
          case MAP:
            step = step._2;
            break;
          case APPLY:
          case ALT:
            if (head2) {
              tail = new Aff2(CONS, head2, tail);
            }
            head2 = step;
            step = step._1;
            break;
        }
      }
      if (count === 0) {
        cb2(util.right(void 0))();
      } else {
        kid = 0;
        tmp = count;
        for (; kid < tmp; kid++) {
          kills2[kid] = kills2[kid]();
        }
      }
      return kills2;
    }
    function join2(result, head2, tail) {
      var fail, step, lhs, rhs, tmp, kid;
      if (util.isLeft(result)) {
        fail = result;
        step = null;
      } else {
        step = result;
        fail = null;
      }
      loop: while (true) {
        lhs = null;
        rhs = null;
        tmp = null;
        kid = null;
        if (interrupt !== null) {
          return;
        }
        if (head2 === null) {
          cb(fail || step)();
          return;
        }
        if (head2._3 !== EMPTY) {
          return;
        }
        switch (head2.tag) {
          case MAP:
            if (fail === null) {
              head2._3 = util.right(head2._1(util.fromRight(step)));
              step = head2._3;
            } else {
              head2._3 = fail;
            }
            break;
          case APPLY:
            lhs = head2._1._3;
            rhs = head2._2._3;
            if (fail) {
              head2._3 = fail;
              tmp = true;
              kid = killId++;
              kills[kid] = kill(early, fail === lhs ? head2._2 : head2._1, function() {
                return function() {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail === null) {
                    join2(fail, null, null);
                  } else {
                    join2(fail, tail._1, tail._2);
                  }
                };
              });
              if (tmp) {
                tmp = false;
                return;
              }
            } else if (lhs === EMPTY || rhs === EMPTY) {
              return;
            } else {
              step = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
              head2._3 = step;
            }
            break;
          case ALT:
            lhs = head2._1._3;
            rhs = head2._2._3;
            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
              return;
            }
            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
              fail = step === lhs ? rhs : lhs;
              step = null;
              head2._3 = fail;
            } else {
              head2._3 = step;
              tmp = true;
              kid = killId++;
              kills[kid] = kill(early, step === lhs ? head2._2 : head2._1, function() {
                return function() {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail === null) {
                    join2(step, null, null);
                  } else {
                    join2(step, tail._1, tail._2);
                  }
                };
              });
              if (tmp) {
                tmp = false;
                return;
              }
            }
            break;
        }
        if (tail === null) {
          head2 = null;
        } else {
          head2 = tail._1;
          tail = tail._2;
        }
      }
    }
    function resolve2(fiber) {
      return function(result) {
        return function() {
          delete fibers[fiber._1];
          fiber._3 = result;
          join2(result, fiber._2._1, fiber._2._2);
        };
      };
    }
    function run3() {
      var status = CONTINUE;
      var step = par;
      var head2 = null;
      var tail = null;
      var tmp, fid;
      loop: while (true) {
        tmp = null;
        fid = null;
        switch (status) {
          case CONTINUE:
            switch (step.tag) {
              case MAP:
                if (head2) {
                  tail = new Aff2(CONS, head2, tail);
                }
                head2 = new Aff2(MAP, step._1, EMPTY, EMPTY);
                step = step._2;
                break;
              case APPLY:
                if (head2) {
                  tail = new Aff2(CONS, head2, tail);
                }
                head2 = new Aff2(APPLY, EMPTY, step._2, EMPTY);
                step = step._1;
                break;
              case ALT:
                if (head2) {
                  tail = new Aff2(CONS, head2, tail);
                }
                head2 = new Aff2(ALT, EMPTY, step._2, EMPTY);
                step = step._1;
                break;
              default:
                fid = fiberId++;
                status = RETURN;
                tmp = step;
                step = new Aff2(FORKED, fid, new Aff2(CONS, head2, tail), EMPTY);
                tmp = Fiber(util, supervisor, tmp);
                tmp.onComplete({
                  rethrow: false,
                  handler: resolve2(step)
                })();
                fibers[fid] = tmp;
                if (supervisor) {
                  supervisor.register(tmp);
                }
            }
            break;
          case RETURN:
            if (head2 === null) {
              break loop;
            }
            if (head2._1 === EMPTY) {
              head2._1 = step;
              status = CONTINUE;
              step = head2._2;
              head2._2 = EMPTY;
            } else {
              head2._2 = step;
              step = head2;
              if (tail === null) {
                head2 = null;
              } else {
                head2 = tail._1;
                tail = tail._2;
              }
            }
        }
      }
      root = step;
      for (fid = 0; fid < fiberId; fid++) {
        fibers[fid].run();
      }
    }
    function cancel(error3, cb2) {
      interrupt = util.left(error3);
      var innerKills;
      for (var kid in kills) {
        if (kills.hasOwnProperty(kid)) {
          innerKills = kills[kid];
          for (kid in innerKills) {
            if (innerKills.hasOwnProperty(kid)) {
              innerKills[kid]();
            }
          }
        }
      }
      kills = null;
      var newKills = kill(error3, root, cb2);
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            for (var kid2 in newKills) {
              if (newKills.hasOwnProperty(kid2)) {
                newKills[kid2]();
              }
            }
            return nonCanceler;
          };
        });
      };
    }
    run3();
    return function(killError) {
      return new Aff2(ASYNC, function(killCb) {
        return function() {
          return cancel(killError, killCb);
        };
      });
    };
  }
  function sequential2(util, supervisor, par) {
    return new Aff2(ASYNC, function(cb) {
      return function() {
        return runPar(util, supervisor, par, cb);
      };
    });
  }
  Aff2.EMPTY = EMPTY;
  Aff2.Pure = AffCtr(PURE);
  Aff2.Throw = AffCtr(THROW);
  Aff2.Catch = AffCtr(CATCH);
  Aff2.Sync = AffCtr(SYNC);
  Aff2.Async = AffCtr(ASYNC);
  Aff2.Bind = AffCtr(BIND);
  Aff2.Bracket = AffCtr(BRACKET);
  Aff2.Fork = AffCtr(FORK);
  Aff2.Seq = AffCtr(SEQ);
  Aff2.ParMap = AffCtr(MAP);
  Aff2.ParApply = AffCtr(APPLY);
  Aff2.ParAlt = AffCtr(ALT);
  Aff2.Fiber = Fiber;
  Aff2.Supervisor = Supervisor;
  Aff2.Scheduler = Scheduler;
  Aff2.nonCanceler = nonCanceler;
  return Aff2;
})();
var _pure = Aff.Pure;
var _throwError = Aff.Throw;
function _catchError(aff) {
  return function(k) {
    return Aff.Catch(aff, k);
  };
}
function _map(f) {
  return function(aff) {
    if (aff.tag === Aff.Pure.tag) {
      return Aff.Pure(f(aff._1));
    } else {
      return Aff.Bind(aff, function(value) {
        return Aff.Pure(f(value));
      });
    }
  };
}
function _bind(aff) {
  return function(k) {
    return Aff.Bind(aff, k);
  };
}
var _liftEffect = Aff.Sync;
var makeAff = Aff.Async;
function _makeFiber(util, aff) {
  return function() {
    return Aff.Fiber(util, null, aff);
  };
}
var _sequential = Aff.Seq;

// output/Effect.Exception/foreign.js
function showErrorImpl(err) {
  return err.stack || err.toString();
}
function error(msg) {
  return new Error(msg);
}

// output/Effect.Exception/index.js
var showError = {
  show: showErrorImpl
};

// output/Control.Monad.Error.Class/index.js
var throwError = function(dict) {
  return dict.throwError;
};
var catchError = function(dict) {
  return dict.catchError;
};
var $$try = function(dictMonadError) {
  var catchError1 = catchError(dictMonadError);
  var Monad0 = dictMonadError.MonadThrow0().Monad0();
  var map13 = map(Monad0.Bind1().Apply0().Functor0());
  var pure7 = pure(Monad0.Applicative0());
  return function(a) {
    return catchError1(map13(Right.create)(a))(function($52) {
      return pure7(Left.create($52));
    });
  };
};

// output/Effect.Class/index.js
var liftEffect = function(dict) {
  return dict.liftEffect;
};

// output/Partial.Unsafe/foreign.js
var _unsafePartial = function(f) {
  return f();
};

// output/Partial/foreign.js
var _crashWith = function(msg) {
  throw new Error(msg);
};

// output/Partial/index.js
var crashWith = function() {
  return _crashWith;
};

// output/Partial.Unsafe/index.js
var crashWith2 = /* @__PURE__ */ crashWith();
var unsafePartial = _unsafePartial;
var unsafeCrashWith = function(msg) {
  return unsafePartial(function() {
    return crashWith2(msg);
  });
};

// output/Effect.Aff/index.js
var $runtime_lazy3 = function(name2, moduleName, init2) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name2 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init2();
    state2 = 2;
    return val;
  };
};
var $$void2 = /* @__PURE__ */ $$void(functorEffect);
var functorAff = {
  map: _map
};
var ffiUtil = /* @__PURE__ */ (function() {
  var unsafeFromRight = function(v) {
    if (v instanceof Right) {
      return v.value0;
    }
    ;
    if (v instanceof Left) {
      return unsafeCrashWith("unsafeFromRight: Left");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v.constructor.name]);
  };
  var unsafeFromLeft = function(v) {
    if (v instanceof Left) {
      return v.value0;
    }
    ;
    if (v instanceof Right) {
      return unsafeCrashWith("unsafeFromLeft: Right");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v.constructor.name]);
  };
  var isLeft = function(v) {
    if (v instanceof Left) {
      return true;
    }
    ;
    if (v instanceof Right) {
      return false;
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v.constructor.name]);
  };
  return {
    isLeft,
    fromLeft: unsafeFromLeft,
    fromRight: unsafeFromRight,
    left: Left.create,
    right: Right.create
  };
})();
var makeFiber = function(aff) {
  return _makeFiber(ffiUtil, aff);
};
var launchAff = function(aff) {
  return function __do() {
    var fiber = makeFiber(aff)();
    fiber.run();
    return fiber;
  };
};
var launchAff_ = function($75) {
  return $$void2(launchAff($75));
};
var monadAff = {
  Applicative0: function() {
    return applicativeAff;
  },
  Bind1: function() {
    return bindAff;
  }
};
var bindAff = {
  bind: _bind,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var applicativeAff = {
  pure: _pure,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy3("applyAff", "Effect.Aff", function() {
  return {
    apply: ap(monadAff),
    Functor0: function() {
      return functorAff;
    }
  };
});
var monadEffectAff = {
  liftEffect: _liftEffect,
  Monad0: function() {
    return monadAff;
  }
};
var monadThrowAff = {
  throwError: _throwError,
  Monad0: function() {
    return monadAff;
  }
};
var monadErrorAff = {
  catchError: _catchError,
  MonadThrow0: function() {
    return monadThrowAff;
  }
};
var $$try2 = /* @__PURE__ */ $$try(monadErrorAff);
var attempt = $$try2;

// output/Effect.Console/foreign.js
var log2 = function(s) {
  return function() {
    console.log(s);
  };
};

// output/Effect.Class.Console/index.js
var log3 = function(dictMonadEffect) {
  var $67 = liftEffect(dictMonadEffect);
  return function($68) {
    return $67(log2($68));
  };
};

// output/Node.Buffer.Immutable/foreign.js
import { Buffer } from "node:buffer";
var fromStringImpl2 = (str, encoding) => Buffer.from(str, encoding);
var toStringImpl = (enc, buff) => buff.toString(enc);

// output/Node.Encoding/index.js
var ASCII = /* @__PURE__ */ (function() {
  function ASCII2() {
  }
  ;
  ASCII2.value = new ASCII2();
  return ASCII2;
})();
var UTF8 = /* @__PURE__ */ (function() {
  function UTF82() {
  }
  ;
  UTF82.value = new UTF82();
  return UTF82;
})();
var UTF16LE = /* @__PURE__ */ (function() {
  function UTF16LE2() {
  }
  ;
  UTF16LE2.value = new UTF16LE2();
  return UTF16LE2;
})();
var UCS2 = /* @__PURE__ */ (function() {
  function UCS22() {
  }
  ;
  UCS22.value = new UCS22();
  return UCS22;
})();
var Base64 = /* @__PURE__ */ (function() {
  function Base642() {
  }
  ;
  Base642.value = new Base642();
  return Base642;
})();
var Base64Url = /* @__PURE__ */ (function() {
  function Base64Url2() {
  }
  ;
  Base64Url2.value = new Base64Url2();
  return Base64Url2;
})();
var Latin1 = /* @__PURE__ */ (function() {
  function Latin12() {
  }
  ;
  Latin12.value = new Latin12();
  return Latin12;
})();
var Binary = /* @__PURE__ */ (function() {
  function Binary2() {
  }
  ;
  Binary2.value = new Binary2();
  return Binary2;
})();
var Hex = /* @__PURE__ */ (function() {
  function Hex2() {
  }
  ;
  Hex2.value = new Hex2();
  return Hex2;
})();
var encodingToNode = function(v) {
  if (v instanceof ASCII) {
    return "ascii";
  }
  ;
  if (v instanceof UTF8) {
    return "utf8";
  }
  ;
  if (v instanceof UTF16LE) {
    return "utf16le";
  }
  ;
  if (v instanceof UCS2) {
    return "ucs2";
  }
  ;
  if (v instanceof Base64) {
    return "base64";
  }
  ;
  if (v instanceof Base64Url) {
    return "base64url";
  }
  ;
  if (v instanceof Latin1) {
    return "latin1";
  }
  ;
  if (v instanceof Binary) {
    return "binary";
  }
  ;
  if (v instanceof Hex) {
    return "hex";
  }
  ;
  throw new Error("Failed pattern match at Node.Encoding (line 35, column 1 - line 35, column 37): " + [v.constructor.name]);
};

// output/Node.Buffer.Immutable/index.js
var toString = function(enc) {
  return function(buf) {
    return toStringImpl(encodingToNode(enc), buf);
  };
};
var fromString = function(str) {
  return function(enc) {
    return fromStringImpl2(str, encodingToNode(enc));
  };
};

// output/Node.Buffer/index.js
var pure2 = /* @__PURE__ */ pure(applicativeEffect);
var map6 = /* @__PURE__ */ map(functorEffect);
var unsafeThaw2 = function($7) {
  return pure2($7);
};
var usingToImmutable = function(f) {
  return function(x) {
    return unsafeThaw2(f(x));
  };
};
var unsafeFreeze2 = function($8) {
  return pure2($8);
};
var usingFromImmutable = function(f) {
  return function(buf) {
    return map6(f)(unsafeFreeze2(buf));
  };
};
var toString2 = function(enc) {
  return usingFromImmutable(toString(enc));
};
var fromString2 = function(s) {
  return usingToImmutable(fromString(s));
};

// output/Node.FS.Stats/foreign.js
var isDirectoryImpl = (s) => s.isDirectory();

// output/Foreign/foreign.js
var isArray = Array.isArray || function(value) {
  return Object.prototype.toString.call(value) === "[object Array]";
};

// output/Node.FS.Stats/index.js
var isDirectory = function(s) {
  return isDirectoryImpl(s);
};

// output/Node.FS.Sync/foreign.js
import {
  accessSync,
  copyFileSync,
  mkdtempSync,
  renameSync,
  truncateSync,
  chownSync,
  chmodSync,
  statSync,
  lstatSync,
  linkSync,
  symlinkSync,
  readlinkSync,
  realpathSync,
  unlinkSync,
  rmdirSync,
  rmSync,
  mkdirSync,
  readdirSync,
  utimesSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  existsSync,
  openSync,
  readSync,
  writeSync,
  fsyncSync,
  closeSync
} from "node:fs";

// output/Node.FS.Constants/foreign.js
import { constants } from "node:fs";
var f_OK = constants.F_OK;
var r_OK = constants.R_OK;
var w_OK = constants.W_OK;
var x_OK = constants.X_OK;
var copyFile_EXCL = constants.COPYFILE_EXCL;
var copyFile_FICLONE = constants.COPYFILE_FICLONE;
var copyFile_FICLONE_FORCE = constants.COPYFILE_FICLONE_FORCE;

// output/Node.FS.Sync/index.js
var writeFile = function(file) {
  return function(buff) {
    return function() {
      return writeFileSync(file, buff, {});
    };
  };
};
var stat = function(file) {
  return function() {
    return statSync(file);
  };
};
var readdir = function(file) {
  return function() {
    return readdirSync(file);
  };
};
var readFile = function(file) {
  return function() {
    return readFileSync(file, {});
  };
};
var exists = function(file) {
  return function() {
    return existsSync(file);
  };
};

// output/Node.Path/foreign.js
import path from "path";
var normalize = path.normalize;
function concat3(segments) {
  return path.join.apply(this, segments);
}
var basename = path.basename;
var extname = path.extname;
var sep = path.sep;
var delimiter = path.delimiter;
var parse2 = path.parse;
var isAbsolute = path.isAbsolute;

// output/HalogenSpider.FileSystem/index.js
var bind2 = /* @__PURE__ */ bind(bindAff);
var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
var throwError2 = /* @__PURE__ */ throwError(monadThrowAff);
var show2 = /* @__PURE__ */ show(showError);
var pure3 = /* @__PURE__ */ pure(applicativeAff);
var map7 = /* @__PURE__ */ map(functorArray);
var traverse2 = /* @__PURE__ */ traverse(traversableArray)(applicativeAff);
var readTextFile = function(path2) {
  return bind2(attempt(liftEffect2(function __do() {
    var buffer = readFile(path2)();
    return toString2(UTF8.value)(buffer)();
  })))(function(result) {
    if (result instanceof Left) {
      return throwError2(error("Failed to read " + (path2 + (": " + show2(result.value0)))));
    }
    ;
    if (result instanceof Right) {
      return pure3(result.value0);
    }
    ;
    throw new Error("Failed pattern match at HalogenSpider.FileSystem (line 25, column 3 - line 27, column 34): " + [result.constructor.name]);
  });
};
var readDir = readdir;
var isDir = function(path2) {
  return function __do() {
    var exists2 = exists(path2)();
    if (exists2) {
      var stats = stat(path2)();
      return isDirectory(stats);
    }
    ;
    return false;
  };
};
var findPursFiles = function(dir) {
  var shouldSkipDir = function(name2) {
    return name2 === "node_modules" || (name2 === "output" || (name2 === ".spago" || (name2 === ".git" || name2 === "bower_components")));
  };
  var isPursFile = function(path2) {
    return drop3(length3(path2) - 5 | 0)(path2) === ".purs";
  };
  var processEntry = function(path2) {
    return bind2(liftEffect2(isDir(path2)))(function(isDirectory2) {
      if (isDirectory2) {
        var basename2 = basename(path2);
        var $19 = shouldSkipDir(basename2);
        if ($19) {
          return pure3([]);
        }
        ;
        return findPursFiles(path2);
      }
      ;
      var $20 = isPursFile(path2);
      if ($20) {
        return pure3([path2]);
      }
      ;
      return pure3([]);
    });
  };
  return bind2(liftEffect2(readDir(dir)))(function(entries) {
    var fullPaths = map7(function(e) {
      return concat3([dir, e]);
    })(entries);
    return bind2(traverse2(processEntry)(fullPaths))(function(results) {
      return pure3(concat(results));
    });
  });
};

// output/HalogenSpider.Graph.Builder/index.js
var difference3 = /* @__PURE__ */ difference2(ordString);
var fromFoldable4 = /* @__PURE__ */ fromFoldable2(foldableSet)(ordString);
var lookup2 = /* @__PURE__ */ lookup(ordString);
var union4 = /* @__PURE__ */ union2(ordString);
var toUnfoldable4 = /* @__PURE__ */ toUnfoldable3(unfoldableArray);
var foldl4 = /* @__PURE__ */ foldl(foldableArray);
var fromFoldable1 = /* @__PURE__ */ fromFoldable(ordString)(foldableArray);
var map8 = /* @__PURE__ */ map(functorArray);
var toUnfoldable1 = /* @__PURE__ */ toUnfoldable(unfoldableArray);
var insert3 = /* @__PURE__ */ insert(ordString);
var fromFoldable22 = /* @__PURE__ */ fromFoldable2(foldableArray)(ordString);
var unusedRoutes = function(allRoutes) {
  return function(usages) {
    return difference3(allRoutes)(fromFoldable4(keys2(usages)));
  };
};
var transitiveClosure = function(graph) {
  return function(start) {
    var addNeighbors = function(acc) {
      return function(node) {
        var neighbors = fromMaybe(empty3)(lookup2(node)(graph));
        return union4(acc)(neighbors);
      };
    };
    var expandFrontier = function(frontier) {
      var frontierArray = toUnfoldable4(frontier);
      return foldl4(addNeighbors)(empty3)(frontierArray);
    };
    var go = function($copy_visited) {
      return function($copy_frontier) {
        var $tco_var_visited = $copy_visited;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(visited, frontier) {
          if (isEmpty2(frontier)) {
            $tco_done = true;
            return visited;
          }
          ;
          if (otherwise) {
            var newVisited = union4(visited)(frontier);
            var nextFrontier = difference3(expandFrontier(frontier))(newVisited);
            $tco_var_visited = newVisited;
            $copy_frontier = nextFrontier;
            return;
          }
          ;
          throw new Error("Failed pattern match at HalogenSpider.Graph.Builder (line 38, column 5 - line 38, column 61): " + [visited.constructor.name, frontier.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_visited, $copy_frontier);
        }
        ;
        return $tco_result;
      };
    };
    return go(empty3)(singleton5(start));
  };
};
var routeDependencies = function(importGraph) {
  return function(routes) {
    var computeDeps = function(mapping) {
      var deps = transitiveClosure(importGraph)(mapping.componentModule);
      return new Tuple(mapping.routeName, deps);
    };
    return fromFoldable1(map8(computeDeps)(routes));
  };
};
var graphToEdges = function(graph) {
  var entryToEdges = function(v) {
    return map8(function(to) {
      return {
        from: v.value0,
        to
      };
    })(toUnfoldable4(v.value1));
  };
  var entries = toUnfoldable1(graph);
  return concatMap(entryToEdges)(entries);
};
var exclusiveDependencies = function(_importGraph) {
  return function(routeDeps) {
    return function(removedRoutes) {
      return function(_allModules) {
        var addRouteDeps = function(acc) {
          return function(route) {
            var deps = fromMaybe(empty3)(lookup2(route)(routeDeps));
            return union4(acc)(deps);
          };
        };
        var removedArray = toUnfoldable4(removedRoutes);
        var removedDeps = foldl4(addRouteDeps)(empty3)(removedArray);
        var remainingRoutes = difference3(fromFoldable4(keys2(routeDeps)))(removedRoutes);
        var remainingArray = toUnfoldable4(remainingRoutes);
        var remainingDeps = foldl4(addRouteDeps)(empty3)(remainingArray);
        return difference3(removedDeps)(remainingDeps);
      };
    };
  };
};
var buildImportGraph = function(modules) {
  var addModule = function(graph) {
    return function(info2) {
      return insert3(info2.moduleName)(fromFoldable22(info2.imports))(graph);
    };
  };
  return foldl4(addModule)(empty2)(modules);
};

// output/HalogenSpider.Output.CSV/index.js
var map9 = /* @__PURE__ */ map(functorArray);
var toUnfoldable5 = /* @__PURE__ */ toUnfoldable3(unfoldableArray);
var append1 = /* @__PURE__ */ append(semigroupArray);
var show3 = /* @__PURE__ */ show(showInt);
var toUnfoldable12 = /* @__PURE__ */ toUnfoldable(unfoldableArray);
var escapeCSV = function(s) {
  var replaceAll2 = function(from2) {
    return function(to) {
      return function(str) {
        return joinWith(to)(split(from2)(str));
      };
    };
  };
  var contains3 = function(p) {
    return function(str) {
      return isJust(indexOf2(p)(str));
    };
  };
  var needsQuotes = any2(function(c) {
    return contains3(c)(s);
  })([",", '"', "\n", ";"]);
  if (needsQuotes) {
    return '"' + (replaceAll2('"')('""')(s) + '"');
  }
  ;
  return s;
};
var orphanedModulesToCSV = function(modules) {
  var lines2 = map9(escapeCSV)(toUnfoldable5(modules));
  return joinWith("\n")(append1(["orphaned_module"])(lines2));
};
var routeDepsToCSV = function(deps) {
  var entryToLine = function(v) {
    var moduleList = toUnfoldable5(v.value1);
    var joined = joinWith(";")(moduleList);
    var count = show3(length(moduleList));
    return escapeCSV(v.value0) + ("," + (count + ("," + escapeCSV(joined))));
  };
  var entries = toUnfoldable12(deps);
  var lines2 = map9(entryToLine)(entries);
  return joinWith("\n")(append1(["route,dependency_count,dependencies"])(lines2));
};
var routeMappingsToCSV = function(mappings) {
  var mappingToLine = function(m) {
    return escapeCSV(m.routeName) + ("," + (escapeCSV(m.componentModule) + ("," + escapeCSV(m.urlPattern))));
  };
  var lines2 = map9(mappingToLine)(mappings);
  return joinWith("\n")(append1(["route,component,url_pattern"])(lines2));
};
var unusedRoutesToCSV = function(routes) {
  var lines2 = map9(escapeCSV)(toUnfoldable5(routes));
  return joinWith("\n")(append1(["unused_route"])(lines2));
};
var edgeHeader = "from,to";
var edgesToCSV = function(edges) {
  var edgeToLine = function(e) {
    return escapeCSV(e.from) + ("," + escapeCSV(e.to));
  };
  return joinWith("\n")(append1([edgeHeader])(map9(edgeToLine)(edges)));
};

// output/HalogenSpider.Output.DOT/index.js
var intercalate3 = /* @__PURE__ */ intercalate2(monoidString);
var map10 = /* @__PURE__ */ map(functorArray);
var append12 = /* @__PURE__ */ append(semigroupArray);
var toUnfoldable6 = /* @__PURE__ */ toUnfoldable3(unfoldableArray);
var routeGraphToDOT = function(mappings) {
  var mappingToEdge = function(m) {
    return '  "' + (m.routeName + ('" -> "' + (m.componentModule + '";')));
  };
  var settings = intercalate3("\n")(["  rankdir=LR;", '  node [fontname="Helvetica"];', "  // Routes", "  node [shape=ellipse, style=filled, fillcolor=lightblue];"]);
  var routeNodes = map10(function(m) {
    return '  "' + (m.routeName + '";');
  })(mappings);
  var edges = map10(mappingToEdge)(mappings);
  return joinWith("\n")(append12(["digraph Routes {", settings])(append12(routeNodes)(append12(["  // Components\n  node [shape=box, style=filled, fillcolor=lightyellow];"])(append12(edges)(["}"])))));
};
var escapeDOT = function(s) {
  var replaceAll2 = function(from2) {
    return function(to) {
      return function(str) {
        return joinWith(to)(split(from2)(str));
      };
    };
  };
  var s1 = replaceAll2('"')('\\"')(s);
  var s2 = replaceAll2("\n")("\\n")(s1);
  return s2;
};
var moduleGraphToDOT = function(title) {
  return function(edges) {
    var edgeToDOT = function(e) {
      return '  "' + (escapeDOT(e.from) + ('" -> "' + (escapeDOT(e.to) + '";')));
    };
    var settings = intercalate3("\n")(["  rankdir=LR;", '  node [shape=box, fontname="Helvetica"];', "  edge [color=gray50];"]);
    var header = 'digraph "' + (title + '" {');
    var edgeLines = map10(edgeToDOT)(edges);
    return joinWith("\n")(append12([header, settings])(append12(edgeLines)(["}"])));
  };
};
var moduleGraphWithHighlightsToDOT = function(title) {
  return function(edges) {
    return function(highlighted) {
      var highlightNode = function(m) {
        return '  "' + (escapeDOT(m) + '" [style=filled, fillcolor=salmon];');
      };
      var edgeToDOT = function(e) {
        return '  "' + (escapeDOT(e.from) + ('" -> "' + (escapeDOT(e.to) + '";')));
      };
      var settings = intercalate3("\n")(["  rankdir=LR;", '  node [shape=box, fontname="Helvetica"];', "  edge [color=gray50];"]);
      var highlightLines = map10(highlightNode)(toUnfoldable6(highlighted));
      var header = 'digraph "' + (title + '" {');
      var edgeLines = map10(edgeToDOT)(edges);
      return joinWith("\n")(append12([header, settings])(append12(highlightLines)(append12(edgeLines)(["}"]))));
    };
  };
};

// output/Data.String.Utils/foreign.js
function linesImpl(str) {
  return str.split(/\r\n|[\n\v\f\r\u0085\u2028\u2029]/);
}

// output/Data.String.Utils/index.js
var lines = function(s) {
  return linesImpl(s);
};

// output/HalogenSpider.Parser.Imports/index.js
var eq2 = /* @__PURE__ */ eq(eqCodePoint);
var bind3 = /* @__PURE__ */ bind(bindMaybe);
var pure4 = /* @__PURE__ */ pure(applicativeMaybe);
var takeUntilWhitespace = function(s) {
  var isSpace = function(cp) {
    return eq2(cp)(codePointFromChar(" ")) || (eq2(cp)(codePointFromChar("(")) || eq2(cp)(codePointFromChar("	")));
  };
  var chars = toCodePointArray(s);
  var taken = takeWhile(function($13) {
    return !isSpace($13);
  })(chars);
  return fromCodePointArray(taken);
};
var parseImportLine = function(line) {
  var trimmed = trim(line);
  var afterImport = drop3(7)(trimmed);
  var moduleName = takeUntilWhitespace(afterImport);
  var $9 = $$null(moduleName);
  if ($9) {
    return Nothing.value;
  }
  ;
  return new Just(moduleName);
};
var parseImportAlias = function(line) {
  var trimmed = trim(line);
  var parts = split(" as ")(trimmed);
  var v = length(parts);
  if (v === 2) {
    return bind3(head(parts))(function(importPart) {
      return bind3(index(parts)(1))(function(aliasPart) {
        var afterImport = drop3(7)(importPart);
        var moduleName = takeUntilWhitespace(afterImport);
        var alias = takeUntilWhitespace(trim(aliasPart));
        var $11 = $$null(moduleName) || $$null(alias);
        if ($11) {
          return Nothing.value;
        }
        ;
        return new Just({
          alias,
          moduleName
        });
      });
    });
  }
  ;
  return Nothing.value;
};
var isModuleLine = function(line) {
  var trimmed = trim(line);
  return take2(7)(trimmed) === "module " && !(take2(2)(trimmed) === "--");
};
var isImportLine = function(line) {
  var trimmed = trim(line);
  return take2(7)(trimmed) === "import " && !(take2(2)(trimmed) === "--");
};
var extractModuleName = function(content) {
  var allLines = lines(content);
  return bind3(find2(isModuleLine)(allLines))(function(moduleLine) {
    var trimmed = trim(moduleLine);
    var afterModule = drop3(7)(trimmed);
    var moduleName = takeUntilWhitespace(afterModule);
    var $12 = $$null(moduleName);
    if ($12) {
      return Nothing.value;
    }
    ;
    return new Just(moduleName);
  });
};
var extractImports = function(content) {
  var allLines = lines(content);
  var importLines = filter(isImportLine)(allLines);
  return mapMaybe(parseImportLine)(importLines);
};
var parseModuleInfo = function(filePath) {
  return function(content) {
    return bind3(extractModuleName(content))(function(moduleName) {
      var imports = extractImports(content);
      return pure4({
        moduleName,
        filePath,
        imports
      });
    });
  };
};
var extractImportAliases = function(content) {
  var allLines = lines(content);
  var importLines = filter(isImportLine)(allLines);
  return mapMaybe(parseImportAlias)(importLines);
};

// output/HalogenSpider.Parser.Routes/index.js
var map11 = /* @__PURE__ */ map(functorArray);
var identity4 = /* @__PURE__ */ identity(categoryFn);
var pure5 = /* @__PURE__ */ pure(applicativeMaybe);
var takeFirstWord = function(s) {
  var isWordChar = function(cp) {
    var c = singleton7(cp);
    return c >= "A" && c <= "Z" || (c >= "a" && c <= "z" || c >= "0" && c <= "9");
  };
  var chars = toCodePointArray(s);
  var taken = takeWhile(isWordChar)(chars);
  return fromCodePointArray(taken);
};
var stringContains = function(needle) {
  return function(haystack) {
    return isJust(indexOf2(needle)(haystack));
  };
};
var isUpperCase = function(s) {
  return s >= "A" && s <= "Z";
};
var isValidConstructor = function(name2) {
  return !$$null(name2) && (isUpperCase(take2(1)(name2)) && name2 !== "Route");
};
var isRouteStart = function(line) {
  var trimmed = trim(line);
  return contains("data Route")(trimmed) || contains("data Route =")(trimmed);
};
var isRouteContinuation = function(line) {
  var trimmed = trim(line);
  return $$null(trimmed) || (take2(1)(trimmed) === "|" || (take2(1)(trimmed) === "=" || (contains("data Route")(trimmed) || !$$null(line) && take2(1)(line) === " ")));
};
var isRouteCaseLine = function(line) {
  var trimmed = trim(line);
  var startsUpper = isUpperCase(take2(1)(trimmed));
  var notComment = !(take2(2)(trimmed) === "--");
  var len = length3(trimmed);
  var lastTwo = drop3(len - 2 | 0)(trimmed);
  var endsWithArrow = lastTwo === "->";
  return endsWithArrow && (startsUpper && notComment);
};
var hasRouteToPath = function(line) {
  return contains("routeToPath")(line);
};
var findRouteDefinition = function(allLines) {
  var indexed = mapWithIndex2(function(i) {
    return function(l) {
      return {
        i,
        l
      };
    };
  })(allLines);
  var startIdx = findIndex(function(v) {
    return isRouteStart(v.l);
  })(indexed);
  if (startIdx instanceof Nothing) {
    return [];
  }
  ;
  if (startIdx instanceof Just) {
    var remaining = drop(startIdx.value0)(allLines);
    return takeWhile(isRouteContinuation)(remaining);
  }
  ;
  throw new Error("Failed pattern match at HalogenSpider.Parser.Routes (line 27, column 6 - line 32, column 55): " + [startIdx.constructor.name]);
};
var findNextCodeLine = function(allLines) {
  return function(startIdx) {
    var checkLine = function($copy_idx) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(idx) {
        var v = index(allLines)(idx);
        if (v instanceof Nothing) {
          $tco_done = true;
          return "";
        }
        ;
        if (v instanceof Just) {
          var trimmed = trim(v.value0);
          var $21 = $$null(trimmed) || take2(2)(trimmed) === "--";
          if ($21) {
            $copy_idx = idx + 1 | 0;
            return;
          }
          ;
          $tco_done = true;
          return trimmed;
        }
        ;
        throw new Error("Failed pattern match at HalogenSpider.Parser.Routes (line 134, column 23 - line 140, column 26): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_idx);
      }
      ;
      return $tco_result;
    };
    return checkLine(startIdx);
  };
};
var extractRouteName = function(s) {
  var name2 = takeFirstWord(trim(s));
  var $23 = isValidConstructor(name2);
  if ($23) {
    return new Just(name2);
  }
  ;
  return Nothing.value;
};
var parseRouteToPathUsage = function(line) {
  var parts = split("routeToPath ")(line);
  var afterKeyword = drop(1)(parts);
  return mapMaybe(extractRouteName)(afterKeyword);
};
var extractRouteUsages = function(content) {
  var allLines = lines(content);
  var usageLines = filter(hasRouteToPath)(allLines);
  return concatMap(parseRouteToPathUsage)(usageLines);
};
var extractConstructorName = function(part) {
  var trimmed = trim(part);
  var withoutEq = (function() {
    var $24 = take2(1)(trimmed) === "=";
    if ($24) {
      return trim(drop3(1)(trimmed));
    }
    ;
    return trimmed;
  })();
  var name2 = takeFirstWord(withoutEq);
  var $25 = isValidConstructor(name2);
  if ($25) {
    return new Just(name2);
  }
  ;
  return Nothing.value;
};
var parseConstructors = function(line) {
  var parts = split("|")(line);
  var cleaned = map11(extractConstructorName)(parts);
  return mapMaybe(identity4)(cleaned);
};
var extractRouteConstructors = function(content) {
  var allLines = lines(content);
  var routeLines = findRouteDefinition(allLines);
  var constructors = concatMap(parseConstructors)(routeLines);
  return constructors;
};
var extractComponentModule = function(rhs) {
  if (stringContains("HH.div_")(rhs)) {
    return "ARCHIVED";
  }
  ;
  if (stringContains(".component")(rhs)) {
    var parts = split(".component")(rhs);
    var v = head(parts);
    if (v instanceof Nothing) {
      return "unknown";
    }
    ;
    if (v instanceof Just) {
      var words = split(" ")(trim(v.value0));
      var lastWord = fromMaybe("unknown")(last(words));
      return lastWord;
    }
    ;
    throw new Error("Failed pattern match at HalogenSpider.Parser.Routes (line 157, column 10 - line 163, column 22): " + [v.constructor.name]);
  }
  ;
  if (otherwise) {
    return "unknown";
  }
  ;
  throw new Error("Failed pattern match at HalogenSpider.Parser.Routes (line 150, column 1 - line 150, column 47): " + [rhs.constructor.name]);
};
var parseRoutePair = function(allLines) {
  return function(v) {
    var trimmed = trim(v.line);
    var withoutArrow = take2(length3(trimmed) - 3 | 0)(trimmed);
    var routeName = takeFirstWord(withoutArrow);
    var componentLine = findNextCodeLine(allLines)(v.idx + 1 | 0);
    var componentModule = extractComponentModule(componentLine);
    var $31 = isValidConstructor(routeName);
    if ($31) {
      return pure5({
        routeName,
        componentModule,
        urlPattern: ""
      });
    }
    ;
    return Nothing.value;
  };
};
var extractRouteMappings = function(content) {
  var allLines = lines(content);
  var indexed = mapWithIndex2(function(i) {
    return function(l) {
      return {
        idx: i,
        line: l
      };
    };
  })(allLines);
  var routeLines = filter(function(x) {
    return isRouteCaseLine(x.line);
  })(indexed);
  return mapMaybe(parseRoutePair(allLines))(routeLines);
};

// output/Node.Process/foreign.js
import process from "process";
var abortImpl = process.abort ? () => process.abort() : null;
var argv = () => process.argv.slice();
var channelRefImpl = process.channel && process.channel.ref ? () => process.channel.ref() : null;
var channelUnrefImpl = process.channel && process.channel.unref ? () => process.channel.unref() : null;
var debugPort = process.debugPort;
var disconnectImpl = process.disconnect ? () => process.disconnect() : null;
var pid = process.pid;
var platformStr = process.platform;
var ppid = process.ppid;
var stdin = process.stdin;
var stdout = process.stdout;
var stderr = process.stderr;
var stdinIsTTY = process.stdinIsTTY;
var stdoutIsTTY = process.stdoutIsTTY;
var stderrIsTTY = process.stderrIsTTY;
var version = process.version;

// output/Foreign.Object/foreign.js
function toArrayWithKey(f) {
  return function(m) {
    var r = [];
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r.push(f(k)(m[k]));
      }
    }
    return r;
  };
}
var keys3 = Object.keys || toArrayWithKey(function(k) {
  return function() {
    return k;
  };
});

// output/Main/index.js
var discard2 = /* @__PURE__ */ discard(discardUnit)(bindAff);
var liftEffect3 = /* @__PURE__ */ liftEffect(monadEffectAff);
var log4 = /* @__PURE__ */ log3(monadEffectAff);
var bind1 = /* @__PURE__ */ bind(bindAff);
var pure6 = /* @__PURE__ */ pure(applicativeAff);
var traverse3 = /* @__PURE__ */ traverse(traversableArray)(applicativeAff);
var map12 = /* @__PURE__ */ map(functorArray);
var insertWith2 = /* @__PURE__ */ insertWith(ordString);
var union5 = /* @__PURE__ */ union2(ordString);
var show4 = /* @__PURE__ */ show(showInt);
var fromFoldable6 = /* @__PURE__ */ fromFoldable2(foldableSet)(ordString);
var fromFoldable12 = /* @__PURE__ */ fromFoldable2(foldableArray)(ordString);
var when2 = /* @__PURE__ */ when(applicativeAff);
var writeOutput = function(path2) {
  return function(content) {
    return discard2(liftEffect3(function __do() {
      var buf = fromString2(content)(UTF8.value)();
      return writeFile(path2)(buf)();
    }))(function() {
      return log4("Wrote: " + path2);
    });
  };
};
var parseAllModules = function(files) {
  var parseFile = function(path2) {
    return bind1(attempt(readTextFile(path2)))(function(result) {
      if (result instanceof Left) {
        return pure6(Nothing.value);
      }
      ;
      if (result instanceof Right) {
        return pure6(parseModuleInfo(path2)(result.value0));
      }
      ;
      throw new Error("Failed pattern match at Main (line 117, column 7 - line 119, column 61): " + [result.constructor.name]);
    });
  };
  return bind1(traverse3(parseFile)(files))(function(results) {
    return pure6(catMaybes(results));
  });
};
var findAllRouteUsages = function(files) {
  var extractUsages = function(path2) {
    return bind1(attempt(readTextFile(path2)))(function(result) {
      if (result instanceof Left) {
        return pure6([]);
      }
      ;
      if (result instanceof Right) {
        var moduleInfo = parseModuleInfo(path2)(result.value0);
        if (moduleInfo instanceof Nothing) {
          return pure6([]);
        }
        ;
        if (moduleInfo instanceof Just) {
          var routes = extractRouteUsages(result.value0);
          return pure6(map12(function(r) {
            return {
              route: r,
              module_: moduleInfo.value0.moduleName
            };
          })(routes));
        }
        ;
        throw new Error("Failed pattern match at Main (line 180, column 11 - line 184, column 82): " + [moduleInfo.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Main (line 176, column 7 - line 184, column 82): " + [result.constructor.name]);
    });
  };
  var addUsage = function(acc) {
    return function(v) {
      return insertWith2(union5)(v.route)(singleton5(v.module_))(acc);
    };
  };
  var mergeUsages = function(usages) {
    return foldl2(addUsage)(empty2)(usages);
  };
  return bind1(traverse3(extractUsages)(files))(function(usages) {
    return pure6(mergeUsages(concat(usages)));
  });
};
var contains2 = function(needle) {
  return function(haystack) {
    return isJust(indexOf2(needle)(haystack));
  };
};
var findRouteConstructors = function(files) {
  var isLikelyRouteFile = function(path2) {
    return contains2("Types.purs")(path2) || contains2("Route")(path2);
  };
  var extractFromFile = function(path2) {
    return bind1(attempt(readTextFile(path2)))(function(result) {
      if (result instanceof Left) {
        return pure6([]);
      }
      ;
      if (result instanceof Right) {
        var $39 = contains2("data Route")(result.value0);
        if ($39) {
          return pure6(extractRouteConstructors(result.value0));
        }
        ;
        return pure6([]);
      }
      ;
      throw new Error("Failed pattern match at Main (line 135, column 7 - line 140, column 25): " + [result.constructor.name]);
    });
  };
  var candidates = filter(isLikelyRouteFile)(files);
  return bind1(traverse3(extractFromFile)(candidates))(function(results) {
    return pure6(concat(results));
  });
};
var findRouteMappings = function(files) {
  var resolveAlias = function(aliases) {
    return function(mapping) {
      var foundAlias = find2(function(a) {
        return a.alias === mapping.componentModule;
      })(aliases);
      if (foundAlias instanceof Just) {
        return {
          routeName: mapping.routeName,
          urlPattern: mapping.urlPattern,
          componentModule: foundAlias.value0.moduleName
        };
      }
      ;
      if (foundAlias instanceof Nothing) {
        return mapping;
      }
      ;
      throw new Error("Failed pattern match at Main (line 164, column 10 - line 166, column 27): " + [foundAlias.constructor.name]);
    };
  };
  var extractFromFile = function(path2) {
    return bind1(attempt(readTextFile(path2)))(function(result) {
      if (result instanceof Left) {
        return pure6([]);
      }
      ;
      if (result instanceof Right) {
        var rawMappings = extractRouteMappings(result.value0);
        var aliases = extractImportAliases(result.value0);
        var resolved = map12(resolveAlias(aliases))(rawMappings);
        return pure6(resolved);
      }
      ;
      throw new Error("Failed pattern match at Main (line 152, column 7 - line 159, column 27): " + [result.constructor.name]);
    });
  };
  var candidates = filter(function(p) {
    return contains2("Main.purs")(p);
  })(files);
  return bind1(traverse3(extractFromFile)(candidates))(function(results) {
    return pure6(concat(results));
  });
};
var analyze = function(targetDir) {
  return discard2(log4("Finding .purs files..."))(function() {
    return bind1(findPursFiles(targetDir + "/src"))(function(pursFiles) {
      return discard2(log4("Found " + (show4(length(pursFiles)) + " files")))(function() {
        return discard2(log4("Parsing module imports..."))(function() {
          return bind1(parseAllModules(pursFiles))(function(moduleInfos) {
            return discard2(log4("Parsed " + (show4(length(moduleInfos)) + " modules")))(function() {
              var importGraph = buildImportGraph(moduleInfos);
              var edges = graphToEdges(importGraph);
              return discard2(log4("Built graph with " + (show4(length(edges)) + " import edges")))(function() {
                return discard2(log4("Looking for route definitions..."))(function() {
                  return bind1(findRouteConstructors(pursFiles))(function(routeConstructors) {
                    return discard2(log4("Found " + (show4(length(routeConstructors)) + " route constructors")))(function() {
                      return bind1(findRouteMappings(pursFiles))(function(routeMappings) {
                        return discard2(log4("Found " + (show4(length(routeMappings)) + " route -> component mappings")))(function() {
                          return discard2(log4("Finding route usages..."))(function() {
                            return bind1(findAllRouteUsages(pursFiles))(function(usageMap) {
                              var usedRoutes = fromFoldable6(keys2(usageMap));
                              return discard2(log4("Found " + (show4(size2(usedRoutes)) + " routes with usages")))(function() {
                                var routeDeps = routeDependencies(importGraph)(routeMappings);
                                return discard2(log4("Computed transitive dependencies per route"))(function() {
                                  var allRoutes = fromFoldable12(routeConstructors);
                                  var unused = unusedRoutes(allRoutes)(usageMap);
                                  return discard2(log4("Found " + (show4(size2(unused)) + " routes with no usages")))(function() {
                                    return discard2(log4("\n--- Writing output files ---"))(function() {
                                      return discard2(writeOutput(targetDir + "/module-graph.csv")(edgesToCSV(edges)))(function() {
                                        return discard2(writeOutput(targetDir + "/module-graph.dot")(moduleGraphToDOT("Module Dependencies")(edges)))(function() {
                                          return discard2(writeOutput(targetDir + "/route-mappings.csv")(routeMappingsToCSV(routeMappings)))(function() {
                                            return discard2(writeOutput(targetDir + "/route-graph.dot")(routeGraphToDOT(routeMappings)))(function() {
                                              return discard2(writeOutput(targetDir + "/route-dependencies.csv")(routeDepsToCSV(routeDeps)))(function() {
                                                return discard2(writeOutput(targetDir + "/unused-routes.csv")(unusedRoutesToCSV(unused)))(function() {
                                                  return discard2(when2(!isEmpty2(unused))((function() {
                                                    var allModules = fromFoldable12(map12(function(v) {
                                                      return v.moduleName;
                                                    })(moduleInfos));
                                                    var orphaned = exclusiveDependencies(importGraph)(routeDeps)(unused)(allModules);
                                                    return discard2(writeOutput(targetDir + "/orphaned-modules.csv")(orphanedModulesToCSV(orphaned)))(function() {
                                                      return discard2(writeOutput(targetDir + "/module-graph-orphans.dot")(moduleGraphWithHighlightsToDOT("Modules (orphans highlighted)")(edges)(orphaned)))(function() {
                                                        return log4("Found " + (show4(size2(orphaned)) + " modules that would be orphaned"));
                                                      });
                                                    });
                                                  })()))(function() {
                                                    return log4("\nDone! Output files written to target directory.");
                                                  });
                                                });
                                              });
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};
var main = /* @__PURE__ */ launchAff_(/* @__PURE__ */ bind1(/* @__PURE__ */ liftEffect3(argv))(function(args) {
  var targetDir = fromMaybe(".")(index(args)(2));
  return discard2(log4("Analyzing Halogen project: " + targetDir))(function() {
    return analyze(targetDir);
  });
}));

// <stdin>
main();
